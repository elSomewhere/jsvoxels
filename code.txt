<codebase><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/.repoignore</path><content>old
.git
*.log
README.md
/.DS_Store
.git</content></file><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/index.html</path><content><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modular Voxel Engine</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        .overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px;
        }
        .stats {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-family: monospace;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <div class="overlay">
        <p>Click to create craters (deform terrain)</p>
        <p>WASD to move, Mouse to look around</p>
        <p>C to move up, X to move down</p>
        <p>SPACE to create crater (where you're looking)</p>
    </div>
    <div class="stats" id="stats">
        <p>FPS: <span id="fps">0</span></p>
        <p>Chunks: <span id="chunks">0</span></p>
        <p>Vertices: <span id="vertices">0</span></p>
        <p>Position: <span id="position">0,0,0</span></p>
    </div>
    
    <!-- Load modules in the correct order -->
    <script type="module" src="js/main.js"></script>
</body>
</html></content></file><codebase><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/js/buffer-manager.js</path><content>// Buffer manager for WebGL buffer pooling and reuse
import { debugLog } from './math-utils.js';
import { BUFFER_POOL_SIZE } from './constants.js';

export class BufferManager {
    constructor(gl) {
        this.gl = gl;

        // Pools for different buffer types
        this.vertexBufferPool = [];
        this.indexBufferPool = [];
        this.normalBufferPool = [];
        this.colorBufferPool = [];
        this.uvBufferPool = [];

        // Currently allocated buffers
        this.allocatedBuffers = new Map();

        // Statistics
        this.stats = {
            created: 0,
            reused: 0,
            released: 0,
            active: 0
        };
    }

    // Get a buffer from pool or create a new one
    getBuffer(type, data, usage = this.gl.STATIC_DRAW) {
        let pool;
        switch (type) {
            case 'vertex':
                pool = this.vertexBufferPool;
                break;
            case 'index':
                pool = this.indexBufferPool;
                break;
            case 'normal':
                pool = this.normalBufferPool;
                break;
            case 'color':
                pool = this.colorBufferPool;
                break;
            case 'uv':
                pool = this.uvBufferPool;
                break;
            default:
                throw new Error(Unknown buffer type: ${type});
        }

        // Find a buffer in the pool that's large enough
        let buffer = null;
        let dataSize = data.byteLength;
        let foundIndex = -1;

        for (let i = 0; i < pool.length; i++) {
            const pooledBuffer = pool[i];
            if (pooledBuffer.size >= dataSize) {
                // Found a suitable buffer
                buffer = pooledBuffer.buffer;
                // Remember the index for removal
                foundIndex = i;
                break;
            }
        }

        // If we found a buffer, remove it from the pool
        if (foundIndex !== -1) {
            pool.splice(foundIndex, 1);
            this.stats.reused++;
        } else {
            // Create a new buffer if none found
            buffer = this.gl.createBuffer();
            this.stats.created++;
        }

        // Bind and upload data
        if (type === 'index') {
            this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, buffer);
            this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, data, usage);
        } else {
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, data, usage);
        }

        // Track this buffer
        const id = Date.now() + Math.random().toString(36).substr(2, 9);
        this.allocatedBuffers.set(id, {
            id,
            buffer,
            type,
            size: dataSize
        });

        this.stats.active++;

        return {
            id,
            buffer
        };
    }

    // Return a buffer to the pool
    releaseBuffer(id) {
        const bufferInfo = this.allocatedBuffers.get(id);
        if (!bufferInfo) {
            return false;
        }

        // Remove from allocated map
        this.allocatedBuffers.delete(id);

        let pool;
        // Select the appropriate pool
        switch (bufferInfo.type) {
            case 'vertex':
                pool = this.vertexBufferPool;
                break;
            case 'index':
                pool = this.indexBufferPool;
                break;
            case 'normal':
                pool = this.normalBufferPool;
                break;
            case 'color':
                pool = this.colorBufferPool;
                break;
            case 'uv':
                pool = this.uvBufferPool;
                break;
        }

        // Check if pool is at max capacity
        if (pool.length >= BUFFER_POOL_SIZE) {
            // Delete the buffer instead of adding to the pool
            this.gl.deleteBuffer(bufferInfo.buffer);
        } else {
            // Add to pool
            pool.push(bufferInfo);
        }

        this.stats.released++;
        this.stats.active--;

        return true;
    }


    // Delete a buffer permanently
    deleteBuffer(id) {
        const bufferInfo = this.allocatedBuffers.get(id);
        if (!bufferInfo) {
            return false;
        }

        // Delete WebGL buffer
        this.gl.deleteBuffer(bufferInfo.buffer);

        // Remove from allocated map
        this.allocatedBuffers.delete(id);

        this.stats.active--;

        return true;
    }

    // Clear all pools
    clearPools() {
        // Delete all buffers in pools
        function clearPool(pool) {
            for (const bufferInfo of pool) {
                this.gl.deleteBuffer(bufferInfo.buffer);
            }
            pool.length = 0;
        }

        clearPool.call(this, this.vertexBufferPool);
        clearPool.call(this, this.indexBufferPool);
        clearPool.call(this, this.normalBufferPool);
        clearPool.call(this, this.colorBufferPool);
        clearPool.call(this, this.uvBufferPool);

        debugLog('BufferManager: All pools cleared');
    }

    // Get buffer stats
    getStats() {
        const poolSizes = {
            vertex: this.vertexBufferPool.length,
            index: this.indexBufferPool.length,
            normal: this.normalBufferPool.length,
            color: this.colorBufferPool.length,
            uv: this.uvBufferPool.length
        };

        return {
            ...this.stats,
            poolSizes
        };
    }

    // Clean up resources
    dispose() {
        // Delete all allocated buffers
        for (const bufferInfo of this.allocatedBuffers.values()) {
            this.gl.deleteBuffer(bufferInfo.buffer);
        }

        // Clear pools
        this.clearPools();

        // Reset stats
        this.stats = {
            created: 0,
            reused: 0,
            released: 0,
            active: 0
        };

        debugLog('BufferManager: Disposed');
    }
}</content></file><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/js/chunk-manager.js</path><content>import { CHUNK_SIZE, RENDER_DISTANCE, ENABLE_MULTITHREADING, USE_TIGHT_BOUNDS } from './constants.js';
import { debugLog } from './math-utils.js';
import { Chunk } from './voxel-data.js';
import { mat4 } from './math-utils.js';

export class ChunkManager {
    constructor(worldGenerator, mesher, renderer, workerPool, spatialIndex, bufferManager) {
        this.worldGenerator = worldGenerator;
        this.mesher = mesher;
        this.renderer = renderer;
        this.workerPool = workerPool;
        this.spatialIndex = spatialIndex;
        this.bufferManager = bufferManager;

        this.chunks = new Map();      // Map of loaded chunks
        this.meshes = new Map();      // Map of chunk meshes
        this.meshBuffers = new Map(); // Map of mesh buffer IDs for cleanup
        this.dirtyChunks = new Set(); // Chunks that need mesh rebuilding
        this.loadQueue = [];          // Queue for chunks to load
        this.unloadQueue = [];        // Queue for chunks to unload
        this.totalChunks = 0;
        this.totalNodes = 0;
        this.cullStats = { total: 0, culled: 0 };
        this.chunkBounds = new Map(); // Map of chunk bounds for culling

        // Pending operations tracking
        this.pendingOperations = new Map(); // Map of chunk keys to pending operations

        // Hysteresis for chunk loading/unloading to prevent flickering
        this.loadedChunkKeys = new Set(); // Set of currently loaded chunk keys
        this.loadMargin = 1.1;  // Keep chunks loaded within 1.1x render distance
        this.unloadMargin = 1.5; // Unload chunks beyond 1.5x render distance
    }

    // Create chunk key from coordinates
    getChunkKey(x, y, z) {
        return ${x},${y},${z};
    }

    // Get chunk at coordinates
    getChunk(x, y, z) {
        return this.chunks.get(this.getChunkKey(x, y, z));
    }

    // Check if chunk exists
    hasChunk(x, y, z) {
        return this.chunks.has(this.getChunkKey(x, y, z));
    }

    // Get chunk mesh
    getChunkMesh(x, y, z) {
        return this.meshes.get(this.getChunkKey(x, y, z));
    }

    // Mark chunk as dirty (needs mesh rebuild)
    markChunkDirty(x, y, z) {
        const key = this.getChunkKey(x, y, z);
        if (this.chunks.has(key)) {
            this.dirtyChunks.add(key);
            debugLog(Marked chunk dirty: ${key});
        }

        // Also mark neighboring chunks as dirty if they could be affected
        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dz = -1; dz <= 1; dz++) {
                    if (dx === 0 && dy === 0 && dz === 0) continue;
                    const neighborKey = this.getChunkKey(x + dx, y + dy, z + dz);
                    if (this.chunks.has(neighborKey)) {
                        this.dirtyChunks.add(neighborKey);
                    }
                }
            }
        }
    }

    // Create or get a chunk
    getOrCreateChunk(chunkX, chunkY, chunkZ) {
        const key = this.getChunkKey(chunkX, chunkY, chunkZ);

        // Return existing chunk if already loaded
        if (this.chunks.has(key)) {
            return this.chunks.get(key);
        }

        // Mark chunk as pending loading
        this.loadedChunkKeys.add(key);

        // Check if there's already a pending operation for this chunk
        if (this.pendingOperations.has(key)) {
            // Create placeholder that can be used while waiting
            const placeholderChunk = new Chunk();
            // IMPORTANT: Don't store this placeholder in this.chunks
            // to avoid race conditions with the real chunk
            return placeholderChunk;
        }

        // Generate a new chunk
        debugLog(Creating new chunk at ${chunkX}, ${chunkY}, ${chunkZ});

        if (ENABLE_MULTITHREADING && this.workerPool) {
            // Record that a generate operation is pending
            this.pendingOperations.set(key, {
                type: 'generate',
                chunkX,
                chunkY,
                chunkZ
            });

            // Queue task for worker pool
            this.workerPool.addTask(
                'generateChunk',
                { chunkX, chunkY, chunkZ },
                this.handleChunkGenerated.bind(this),
                [], // No transferables for this task
                true // Priority task for nearby chunks
            );

            // Return a placeholder empty chunk while waiting
            // IMPORTANT: Don't store this placeholder in this.chunks
            const placeholderChunk = new Chunk();
            return placeholderChunk;
        } else {
            // Generate chunk synchronously
            const chunk = this.worldGenerator.generateChunk(chunkX, chunkY, chunkZ);

            // Store the chunk in the global chunk map
            this.chunks.set(key, chunk);

            // Mark for meshing
            this.dirtyChunks.add(key);
            this.totalChunks++;

            // Add to spatial index
            this.spatialIndex.addChunk(chunkX, chunkY, chunkZ, chunk);

            // Calculate tight bounds if enabled
            if (USE_TIGHT_BOUNDS) {
                const bounds = this.spatialIndex.calculateTightBounds(chunkX, chunkY, chunkZ, chunk);
                this.chunkBounds.set(key, bounds);
            }

            return chunk;
        }
    }

    // Handle chunk generation completion from worker
    handleChunkGenerated(result) {
        const { chunkX, chunkY, chunkZ, voxelData } = result;
        const key = this.getChunkKey(chunkX, chunkY, chunkZ);

        // Check if we still need this chunk (it might have been unloaded while generating)
        if (!this.loadedChunkKeys.has(key)) {
            this.pendingOperations.delete(key);
            return;
        }

        // Create chunk from voxel data
        const chunk = new Chunk();
        chunk.fillFromArray(voxelData);

        // Store chunk
        this.chunks.set(key, chunk);
        this.dirtyChunks.add(key);
        this.totalChunks++;

        // Add to spatial index
        this.spatialIndex.addChunk(chunkX, chunkY, chunkZ, chunk);

        // Calculate tight bounds if enabled
        if (USE_TIGHT_BOUNDS) {
            const bounds = this.spatialIndex.calculateTightBounds(chunkX, chunkY, chunkZ, chunk);
            this.chunkBounds.set(key, bounds);
        }

        // Remove from pending operations
        this.pendingOperations.delete(key);

        debugLog(Chunk generated from worker: ${key});
    }

    // Update chunks based on player position
    updateChunks(playerX, playerY, playerZ) {
        // Convert player position to chunk coordinates
        const centerChunkX = Math.floor(playerX / CHUNK_SIZE);
        const centerChunkY = Math.floor(playerY / CHUNK_SIZE);
        const centerChunkZ = Math.floor(playerZ / CHUNK_SIZE);

        // Use spatial index to find chunks in radius
        const chunksToLoad = [];

        // Increase load radius margin to load chunks before they're needed
        const loadRadiusSquared = Math.pow(RENDER_DISTANCE * this.loadMargin, 2);

        // Use a more conservative unload margin
        const unloadRadiusSquared = Math.pow(RENDER_DISTANCE * this.unloadMargin, 2);

        // Define the range for chunk loading slightly wider than render distance
        const loadRangeHorizontal = RENDER_DISTANCE + 2;
        const loadRangeVertical = Math.max(2, Math.floor(RENDER_DISTANCE / 2)); // Less in vertical direction

        for (let x = centerChunkX - loadRangeHorizontal; x <= centerChunkX + loadRangeHorizontal; x++) {
            for (let y = 0; y <= centerChunkY + loadRangeVertical; y++) {
                for (let z = centerChunkZ - loadRangeHorizontal; z <= centerChunkZ + loadRangeHorizontal; z++) {
                    // Use spherical distance for loading
                    const dx = x - centerChunkX;
                    const dy = y - centerChunkY;
                    const dz = z - centerChunkZ;
                    const distSquared = dx * dx + dy * dy + dz * dz;

                    const key = this.getChunkKey(x, y, z);
                    if (distSquared <= loadRadiusSquared &&
                        !this.hasChunk(x, y, z) &&
                        !this.pendingOperations.has(key)) {
                        // Prioritize chunks closer to player
                        chunksToLoad.push({ coords: [x, y, z], dist: distSquared });
                        // Mark as potentially loaded to prevent adding it multiple times
                        this.loadedChunkKeys.add(key);
                    }
                }
            }
        }

        // Sort load queue by distance for priority loading
        chunksToLoad.sort((a, b) => a.dist - b.dist);

        // Add new chunks to load queue (no duplicates)
        for (const chunk of chunksToLoad) {
            if (!this.loadQueue.some(c =>
                c.coords[0] === chunk.coords[0] &&
                c.coords[1] === chunk.coords[1] &&
                c.coords[2] === chunk.coords[2])) {
                this.loadQueue.push(chunk);
            }
        }

        // Find chunks to unload with a much larger distance threshold
        const chunksToUnload = [];

        for (const [key, chunk] of this.chunks.entries()) {
            const [x, y, z] = key.split(',').map(Number);
            const dx = x - centerChunkX;
            const dy = y - centerChunkY;
            const dz = z - centerChunkZ;
            const distSquared = dx * dx + dy * dy + dz * dz;

            // Use a much larger unload radius to prevent frequent loading/unloading
            if (distSquared > unloadRadiusSquared) {
                chunksToUnload.push([x, y, z]);
                // Remove from loaded chunks set
                this.loadedChunkKeys.delete(key);
            }
        }

        // Process load queue (increased per frame)
        const loadLimit = 4; // Increased from 2
        let loaded = 0;

        while (this.loadQueue.length > 0 && loaded < loadLimit) {
            const { coords } = this.loadQueue.shift();
            const [x, y, z] = coords;
            if (!this.hasChunk(x, y, z) && !this.pendingOperations.has(this.getChunkKey(x, y, z))) {
                this.getOrCreateChunk(x, y, z);
                loaded++;
            }
        }

        // Process unload queue (one at a time to avoid sudden changes)
        const unloadLimit = 1;
        let unloaded = 0;

        while (this.unloadQueue.length > 0 && unloaded < unloadLimit) {
            const [x, y, z] = this.unloadQueue.shift();
            this.unloadChunk(x, y, z);
            unloaded++;
        }

        // Update total octree node count for stats
        this.updateNodeCount();

        // Update stats display
        document.getElementById('chunks').textContent = this.totalChunks;
        document.getElementById('position').textContent = ${Math.floor(playerX)},${Math.floor(playerY)},${Math.floor(playerZ)};
    }

    // Count total nodes in all octrees (for stats display)
    updateNodeCount() {
        let nodeCount = 0;
        for (const chunk of this.chunks.values()) {
            if (chunk.rootNode) {
                nodeCount += chunk.countNodes ? chunk.countNodes() : 1;
            }
        }
        this.totalNodes = nodeCount;
    }

    // Unload a chunk
    unloadChunk(x, y, z) {
        const key = this.getChunkKey(x, y, z);

        if (this.chunks.has(key)) {
            this.chunks.delete(key);

            // Delete mesh if it exists
            if (this.meshes.has(key)) {
                const mesh = this.meshes.get(key);
                this.renderer.deleteMesh(mesh);
                this.meshes.delete(key);

                // Clean up buffer IDs
                if (this.meshBuffers.has(key)) {
                    for (const bufferId of this.meshBuffers.get(key)) {
                        this.bufferManager.releaseBuffer(bufferId);
                    }
                    this.meshBuffers.delete(key);
                }
            }

            this.dirtyChunks.delete(key);
            this.totalChunks--;

            // Remove from spatial index
            this.spatialIndex.removeChunk(x, y, z);

            // Remove bounds
            this.chunkBounds.delete(key);

            // Cancel any pending operations
            if (this.pendingOperations.has(key)) {
                // We can't cancel worker tasks directly, but we can ignore their results
                this.pendingOperations.delete(key);
            }

            // Remove from loaded chunks set
            this.loadedChunkKeys.delete(key);

            debugLog(Unloaded chunk at ${x}, ${y}, ${z});
        }
    }

    // Build/rebuild meshes for dirty chunks
    buildChunkMeshes() {
        // Limit rebuilds per frame
        const rebuildLimit = 2;
        let rebuilt = 0;

        for (const key of this.dirtyChunks) {
            if (rebuilt >= rebuildLimit) break;

            const [x, y, z] = key.split(',').map(Number);
            const chunk = this.getChunk(x, y, z);

            if (chunk) {
                // Skip if there's already a pending mesh operation
                if (this.pendingOperations.has(key) && this.pendingOperations.get(key).type === 'mesh') {
                    continue;
                }

                // Skip if chunk is no longer needed (outside render distance)
                if (!this.loadedChunkKeys.has(key)) {
                    this.dirtyChunks.delete(key);
                    continue;
                }

                if (ENABLE_MULTITHREADING && this.workerPool) {
                    // Get neighbor chunks for proper meshing
                    const neighbors = [];
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dz = -1; dz <= 1; dz++) {
                                if (dx === 0 && dy === 0 && dz === 0) continue;

                                const nx = x + dx;
                                const ny = y + dy;
                                const nz = z + dz;
                                const nkey = this.getChunkKey(nx, ny, nz);

                                if (this.chunks.has(nkey)) {
                                    const neighbor = this.chunks.get(nkey);
                                    // Serialize neighbor chunk data
                                    neighbors.push({
                                        x: nx,
                                        y: ny,
                                        z: nz,
                                        voxelData: neighbor.serialize()
                                    });
                                }
                            }
                        }
                    }

                    // Mark as pending
                    this.pendingOperations.set(key, {
                        type: 'mesh',
                        x, y, z
                    });

                    // Queue meshing task for worker
                    this.workerPool.addTask(
                        'generateMesh',
                        {
                            chunkData: chunk.serialize(),
                            x, y, z,
                            neighbors
                        },
                        (meshData) => this.handleMeshGenerated(x, y, z, meshData),
                        [], // Transferables will be set by worker
                        false // Meshing is not as high priority as chunk generation
                    );

                    rebuilt++;
                } else {
                    // Generate mesh synchronously
                    const mesh = this.mesher.generateMesh(chunk, x, y, z,
                        (cx, cy, cz) => this.getChunk(cx, cy, cz));

                    // Skip if no vertices (empty chunk)
                    if (mesh.positions.length === 0) {
                        this.dirtyChunks.delete(key);
                        // Delete existing mesh if it exists
                        if (this.meshes.has(key)) {
                            this.renderer.deleteMesh(this.meshes.get(key));
                            this.meshes.delete(key);

                            // Clean up buffer IDs
                            if (this.meshBuffers.has(key)) {
                                for (const bufferId of this.meshBuffers.get(key)) {
                                    this.bufferManager.releaseBuffer(bufferId);
                                }
                                this.meshBuffers.delete(key);
                            }
                        }
                        continue;
                    }

                    // Create WebGL mesh
                    const worldOffset = [x * CHUNK_SIZE, y * CHUNK_SIZE, z * CHUNK_SIZE];
                    const useTextures = mesh.uvs && mesh.uvs.length > 0;
                    const glMesh = this.renderer.createMesh(mesh, worldOffset, useTextures);

                    // Store buffer IDs for cleanup
                    if (glMesh.bufferIds) {
                        this.meshBuffers.set(key, glMesh.bufferIds);
                    }

                    // Update with tight bounds if enabled
                    if (USE_TIGHT_BOUNDS && this.chunkBounds.has(key)) {
                        glMesh.bounds = this.chunkBounds.get(key);
                    }

                    // Delete old mesh if it exists
                    if (this.meshes.has(key)) {
                        this.renderer.deleteMesh(this.meshes.get(key));

                        // Clean up buffer IDs
                        if (this.meshBuffers.has(key)) {
                            for (const bufferId of this.meshBuffers.get(key)) {
                                this.bufferManager.releaseBuffer(bufferId);
                            }
                        }
                    }

                    // Store mesh
                    this.meshes.set(key, glMesh);
                    this.dirtyChunks.delete(key);
                    rebuilt++;

                    debugLog(Built mesh for chunk ${key}: ${mesh.positions.length / 3} vertices);
                }
            }
        }

        // Update total vertex count
        let totalVertices = 0;
        for (const mesh of this.meshes.values()) {
            totalVertices += mesh.vertexCount;
        }
        document.getElementById('vertices').textContent = totalVertices;
    }

    // Handle mesh generation completion from worker
    handleMeshGenerated(x, y, z, meshData) {
        const key = this.getChunkKey(x, y, z);

        // Skip if chunk no longer exists or is no longer needed
        if (!this.chunks.has(key) || !this.loadedChunkKeys.has(key)) {
            this.pendingOperations.delete(key);
            return;
        }

        // Skip if empty mesh
        if (meshData.vertexCount === 0) {
            this.dirtyChunks.delete(key);
            this.pendingOperations.delete(key);

            // Delete existing mesh if it exists
            if (this.meshes.has(key)) {
                this.renderer.deleteMesh(this.meshes.get(key));
                this.meshes.delete(key);

                // Clean up buffer IDs
                if (this.meshBuffers.has(key)) {
                    for (const bufferId of this.meshBuffers.get(key)) {
                        this.bufferManager.releaseBuffer(bufferId);
                    }
                    this.meshBuffers.delete(key);
                }
            }

            return;
        }

        // Convert typed arrays back to mesh data
        const mesh = {
            positions: Array.from(meshData.vertexBuffer),
            normals: Array.from(meshData.normalBuffer),
            colors: Array.from(meshData.colorBuffer),
            indices: Array.from(meshData.indexBuffer)
        };

        // Add UVs if available
        if (meshData.uvBuffer) {
            mesh.uvs = Array.from(meshData.uvBuffer);
        }

        // Create WebGL mesh
        const worldOffset = [x * CHUNK_SIZE, y * CHUNK_SIZE, z * CHUNK_SIZE];
        const useTextures = mesh.uvs && mesh.uvs.length > 0;
        const glMesh = this.renderer.createMesh(mesh, worldOffset, useTextures);

        // Store buffer IDs for cleanup
        if (glMesh.bufferIds) {
            this.meshBuffers.set(key, glMesh.bufferIds);
        }

        // Update with tight bounds if enabled
        if (USE_TIGHT_BOUNDS && this.chunkBounds.has(key)) {
            glMesh.bounds = this.chunkBounds.get(key);
        }

        // Delete old mesh if it exists
        if (this.meshes.has(key)) {
            this.renderer.deleteMesh(this.meshes.get(key));

            // Clean up buffer IDs
            if (this.meshBuffers.has(key)) {
                for (const bufferId of this.meshBuffers.get(key)) {
                    this.bufferManager.releaseBuffer(bufferId);
                }
            }
        }

        // Store mesh and mark as not dirty
        this.meshes.set(key, glMesh);
        this.dirtyChunks.delete(key);
        this.pendingOperations.delete(key);

        debugLog(Built mesh from worker for chunk ${key}: ${meshData.vertexCount} vertices);
    }

    // Get voxel at world coordinates
    getVoxel(worldX, worldY, worldZ) {
        // Convert to chunk coordinates
        const chunkX = Math.floor(worldX / CHUNK_SIZE);
        const chunkY = Math.floor(worldY / CHUNK_SIZE);
        const chunkZ = Math.floor(worldZ / CHUNK_SIZE);

        // Get chunk
        const chunk = this.getChunk(chunkX, chunkY, chunkZ);
        if (!chunk) {
            return 0; // Assume air if chunk not loaded
        }

        // Convert to local coordinates
        const localX = ((worldX % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
        const localY = ((worldY % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
        const localZ = ((worldZ % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

        return chunk.getVoxel(localX, localY, localZ);
    }

    // Set voxel at world coordinates
    setVoxel(worldX, worldY, worldZ, voxelType) {
        // Convert to chunk coordinates
        const chunkX = Math.floor(worldX / CHUNK_SIZE);
        const chunkY = Math.floor(worldY / CHUNK_SIZE);
        const chunkZ = Math.floor(worldZ / CHUNK_SIZE);

        // Convert to local coordinates within chunk
        const localX = ((worldX % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
        const localY = ((worldY % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
        const localZ = ((worldZ % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

        debugLog(Setting voxel at ${worldX},${worldY},${worldZ} (chunk ${chunkX},${chunkY},${chunkZ}, local ${localX},${localY},${localZ}));

        // Get or create chunk
        let chunk = this.getChunk(chunkX, chunkY, chunkZ);
        if (!chunk) {
            chunk = this.getOrCreateChunk(chunkX, chunkY, chunkZ);
        }

        // Update voxel in chunk
        chunk.setVoxel(localX, localY, localZ, voxelType);

        // Mark chunk as dirty
        this.markChunkDirty(chunkX, chunkY, chunkZ);

        // Mark neighboring chunks as dirty if this voxel is on a boundary
        if (localX === 0) this.markChunkDirty(chunkX - 1, chunkY, chunkZ);
        if (localX === CHUNK_SIZE - 1) this.markChunkDirty(chunkX + 1, chunkY, chunkZ);
        if (localY === 0) this.markChunkDirty(chunkX, chunkY - 1, chunkZ);
        if (localY === CHUNK_SIZE - 1) this.markChunkDirty(chunkX, chunkY + 1, chunkZ);
        if (localZ === 0) this.markChunkDirty(chunkX, chunkY, chunkZ - 1);
        if (localZ === CHUNK_SIZE - 1) this.markChunkDirty(chunkX, chunkY, chunkZ + 1);

        // Update bounds
        if (USE_TIGHT_BOUNDS) {
            const key = this.getChunkKey(chunkX, chunkY, chunkZ);
            const bounds = this.spatialIndex.calculateTightBounds(chunkX, chunkY, chunkZ, chunk);
            this.chunkBounds.set(key, bounds);
        }
    }

    // Create a crater at world coordinates
    createCrater(worldX, worldY, worldZ, radius) {
        debugLog(Creating crater at ${worldX}, ${worldY}, ${worldZ} with radius ${radius});

        if (ENABLE_MULTITHREADING && this.workerPool) {
            // Get chunks that might be affected
            const chunkRadius = Math.ceil(radius / CHUNK_SIZE) + 1;
            const centerChunkX = Math.floor(worldX / CHUNK_SIZE);
            const centerChunkY = Math.floor(worldY / CHUNK_SIZE);
            const centerChunkZ = Math.floor(worldZ / CHUNK_SIZE);

            // Collect chunks in radius
            const chunks = [];
            for (let cx = centerChunkX - chunkRadius; cx <= centerChunkX + chunkRadius; cx++) {
                for (let cy = centerChunkY - chunkRadius; cy <= centerChunkY + chunkRadius; cy++) {
                    for (let cz = centerChunkZ - chunkRadius; cz <= centerChunkZ + chunkRadius; cz++) {
                        const key = this.getChunkKey(cx, cy, cz);
                        if (this.chunks.has(key)) {
                            const chunk = this.chunks.get(key);
                            chunks.push({
                                chunkX: cx,
                                chunkY: cy,
                                chunkZ: cz,
                                voxelData: chunk.serialize()
                            });
                        }
                    }
                }
            }

            // Send task to worker
            this.workerPool.addTask(
                'createCrater',
                {
                    centerX: worldX,
                    centerY: worldY,
                    centerZ: worldZ,
                    radius,
                    chunks
                },
                this.handleCraterCreated.bind(this),
                [], // No transferables for now
                true // Priority task
            );
        } else {
            // Process crater synchronously
            const radiusSquared = radius * radius;

            for (let dx = -radius; dx <= radius; dx++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dz = -radius; dz <= radius; dz++) {
                        const distSquared = dx * dx + dy * dy + dz * dz;
                        if (distSquared <= radiusSquared) {
                            this.setVoxel(Math.floor(worldX + dx), Math.floor(worldY + dy), Math.floor(worldZ + dz), 0);
                        }
                    }
                }
            }
        }
    }

    // Handle crater creation completed by worker
    handleCraterCreated(result) {
        const { modifiedChunks } = result;

        // Update each modified chunk
        for (const chunkData of modifiedChunks) {
            const { chunkX, chunkY, chunkZ, voxelData } = chunkData;
            const key = this.getChunkKey(chunkX, chunkY, chunkZ);

            // Get chunk if it exists
            if (this.chunks.has(key)) {
                const chunk = this.chunks.get(key);

                // Update with new data
                chunk.fillFromArray(voxelData);

                // Mark as dirty for mesh rebuild
                this.dirtyChunks.add(key);

                // Update bounds
                if (USE_TIGHT_BOUNDS) {
                    const bounds = this.spatialIndex.calculateTightBounds(chunkX, chunkY, chunkZ, chunk);
                    this.chunkBounds.set(key, bounds);
                }
            }
        }
    }

    // Perform raycast against voxels
    raycast(origin, direction, maxDistance = 100) {
        debugLog(Raycasting from ${origin} in direction ${direction});

        const stepSize = 0.1;
        const maxSteps = maxDistance / stepSize;

        let currentPos = [...origin];
        let lastPos = [...origin];

        for (let i = 0; i < maxSteps; i++) {
            lastPos = [...currentPos]; // Save last position for normal calculation

            // Move along the ray
            currentPos[0] += direction[0] * stepSize;
            currentPos[1] += direction[1] * stepSize;
            currentPos[2] += direction[2] * stepSize;

            const x = Math.floor(currentPos[0]);
            const y = Math.floor(currentPos[1]);
            const z = Math.floor(currentPos[2]);

            // Check if we've hit a voxel
            const voxel = this.getVoxel(x, y, z);
            if (voxel !== 0) {
                // Calculate hit normal based on which face was hit
                const dx = currentPos[0] - lastPos[0];
                const dy = currentPos[1] - lastPos[1];
                const dz = currentPos[2] - lastPos[2];

                // Determine which axis had the largest movement
                let normal = [0, 0, 0];
                if (Math.abs(dx) >= Math.abs(dy) && Math.abs(dx) >= Math.abs(dz)) {
                    normal[0] = dx > 0 ? -1 : 1;
                } else if (Math.abs(dy) >= Math.abs(dx) && Math.abs(dy) >= Math.abs(dz)) {
                    normal[1] = dy > 0 ? -1 : 1;
                } else {
                    normal[2] = dz > 0 ? -1 : 1;
                }

                debugLog(Raycast hit at ${x}, ${y}, ${z}, voxel type: ${voxel});
                return {
                    position: [x, y, z],
                    voxelType: voxel,
                    distance: i * stepSize,
                    normal
                };
            }
        }

        debugLog(Raycast missed (exceeded maxDistance));
        return null; // No hit
    }

    // Render all chunks with frustum culling
    render(projectionMatrix, viewMatrix) {
        // Create combined projection-view matrix
        const projViewMatrix = mat4.create();
        mat4.multiply(projViewMatrix, projectionMatrix, viewMatrix);

        // Get visible meshes using spatial index
        const cameraPosition = [
            -viewMatrix[12], -viewMatrix[13], -viewMatrix[14]
        ];

        // Update frustum for culling
        const frustum = mat4.frustumFromMatrix(projViewMatrix);

        // Filter meshes based on frustum culling using either spatial index or direct iteration
        let visibleMeshes;
        if (this.spatialIndex) {
            // Use spatial index to find potentially visible chunks
            const visibleChunks = this.spatialIndex.findVisibleChunks(cameraPosition, frustum);
            this.cullStats.total = this.meshes.size;

            // Get meshes for visible chunks
            visibleMeshes = visibleChunks
                .map(({ x, y, z }) => this.getChunkMesh(x, y, z))
                .filter(mesh => mesh !== undefined);

            this.cullStats.culled = this.cullStats.total - visibleMeshes.length;
        } else {
            // Fall back to direct iteration and culling
            const meshArray = Array.from(this.meshes.values());
            this.cullStats.total = meshArray.length;

            visibleMeshes = meshArray.filter(mesh =>
                mesh && this.renderer.isMeshInFrustum(mesh, projViewMatrix)
            );

            this.cullStats.culled = this.cullStats.total - visibleMeshes.length;
        }

        // Render visible meshes
        return this.renderer.renderChunks(visibleMeshes, projectionMatrix, viewMatrix);
    }
}</content></file><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/js/constants.js</path><content>export const CHUNK_SIZE = 16;
export const RENDER_DISTANCE = 5;
export const MAX_HEIGHT = 64;
export const DEBUG = true;

// New constants for multithreading and optimization
export const WORKER_COUNT = navigator.hardwareConcurrency || 4;
export const TASK_PRIORITY_DISTANCE = CHUNK_SIZE * 2; // Distance at which tasks get priority
export const BUFFER_POOL_SIZE = 50; // Maximum number of buffers to keep in pool
export const ENABLE_FRUSTUM_CULLING = true; // Enable/disable frustum culling
export const DEBUG_FRUSTUM_CULLING = true; // When true, will log frustum culling info
export const ENABLE_MULTITHREADING = true; // Enable/disable multithreading
export const ENABLE_TEXTURE_ATLAS = true; // Enable/disable texture atlas
export const USE_TIGHT_BOUNDS = true; // Use tight bounding boxes for culling</content></file><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/js/controls.js</path><content>import { normalizeVector, debugLog } from './math-utils.js';
import { VoxelType } from './voxel-types.js';

export class Controls {
    constructor(canvas, camera, chunkManager) {
        this.canvas = canvas;
        this.camera = camera;
        this.chunkManager = chunkManager;

        // Movement state
        this.moveForward = false;
        this.moveBackward = false;
        this.moveLeft = false;
        this.moveRight = false;
        this.moveUp = false;
        this.moveDown = false;

        // Mouse state
        this.isPointerLocked = false;

        this.setupInputHandlers();
    }

    setupInputHandlers() {
        // Mouse movement for camera rotation
        document.addEventListener('mousemove', (e) => {
            if (this.isPointerLocked) {
                const sensitivity = 0.002;
                this.camera.rotation[0] -= e.movementX * sensitivity;
                this.camera.rotation[1] -= e.movementY * sensitivity;

                // Clamp vertical rotation to prevent flipping
                this.camera.rotation[1] = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, this.camera.rotation[1]));

                // Normalize yaw rotation to keep it in a reasonable range
                this.camera.rotation[0] = this.camera.rotation[0] % (2 * Math.PI);
                if (this.camera.rotation[0] < 0) {
                    this.camera.rotation[0] += 2 * Math.PI;
                }
            }
        });

        // Handle pointer lock
        document.addEventListener('pointerlockchange', () => {
            this.isPointerLocked = document.pointerLockElement === this.canvas;
            debugLog(Pointer lock: ${this.isPointerLocked});
        });

        // Click to lock pointer
        this.canvas.addEventListener('click', () => {
            if (!this.isPointerLocked) {
                this.canvas.requestPointerLock();
            }
        });

        // Mouse down to create crater
        this.canvas.addEventListener('mousedown', (e) => {
            // Only proceed if pointer is locked (we have control)
            if (this.isPointerLocked) {
                this.createCraterAtLookDirection(3);
            }
        });

        // Keyboard controls
        window.addEventListener('keydown', (e) => {
            switch (e.key.toLowerCase()) {
                case 'w': this.moveForward = true; break;
                case 's': this.moveBackward = true; break;
                case 'a': this.moveLeft = true; break;
                case 'd': this.moveRight = true; break;
                case 'c': this.moveUp = true; break;
                case 'x': this.moveDown = true; break;
                case ' ': // Space to create crater at look direction
                    this.createCraterAtLookDirection(5);
                    break;
            }
        });

        window.addEventListener('keyup', (e) => {
            switch (e.key.toLowerCase()) {
                case 'w': this.moveForward = false; break;
                case 's': this.moveBackward = false; break;
                case 'a': this.moveLeft = false; break;
                case 'd': this.moveRight = false; break;
                case 'c': this.moveUp = false; break;
                case 'x': this.moveDown = false; break;
            }
        });
    }

    createCraterAtLookDirection(radius) {
        // Calculate ray from camera
        const ray = {
            origin: [...this.camera.position],
            direction: this.getLookDirection()
        };

        // Raycast to find hit point
        const hit = this.chunkManager.raycast(ray.origin, ray.direction, 50);
        if (hit) {
            this.chunkManager.createCrater(hit.position[0], hit.position[1], hit.position[2], radius);
        }
    }

    getLookDirection() {
        const direction = [
            Math.sin(this.camera.rotation[0]) * Math.cos(this.camera.rotation[1]),
            Math.sin(this.camera.rotation[1]),
            Math.cos(this.camera.rotation[0]) * Math.cos(this.camera.rotation[1])
        ];

        return normalizeVector(direction);
    }

    update(deltaTime) {
        // Get forward and right vectors
        const forward = [
            Math.sin(this.camera.rotation[0]) * Math.cos(this.camera.rotation[1]),
            0, // No vertical component for forward movement
            Math.cos(this.camera.rotation[0]) * Math.cos(this.camera.rotation[1])
        ];
        normalizeVector(forward);

        const right = [
            Math.sin(this.camera.rotation[0] + Math.PI / 2),
            0,
            Math.cos(this.camera.rotation[0] + Math.PI / 2)
        ];

        // Apply movement
        const moveSpeed = 10 * deltaTime; // Units per second

        if (this.moveForward) {
            this.camera.position[0] += forward[0] * moveSpeed;
            this.camera.position[2] += forward[2] * moveSpeed;
        }
        if (this.moveBackward) {
            this.camera.position[0] -= forward[0] * moveSpeed;
            this.camera.position[2] -= forward[2] * moveSpeed;
        }
        if (this.moveRight) {
            this.camera.position[0] += right[0] * moveSpeed;
            this.camera.position[2] += right[2] * moveSpeed;
        }
        if (this.moveLeft) {
            this.camera.position[0] -= right[0] * moveSpeed;
            this.camera.position[2] -= right[2] * moveSpeed;
        }
        if (this.moveUp) {
            this.camera.position[1] += moveSpeed;
        }
        if (this.moveDown) {
            this.camera.position[1] -= moveSpeed;
        }
    }
}</content></file><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/js/main.js</path><content>import { CHUNK_SIZE, RENDER_DISTANCE, WORKER_COUNT, ENABLE_MULTITHREADING, DEBUG } from './constants.js';
import { mat4 } from './math-utils.js';
import { VoxelTypeManager } from './voxel-types.js';
import { WorldGenerator } from './world-generator.js';
import { Mesher } from './mesher.js';
import { ChunkManager } from './chunk-manager.js';
import { Renderer } from './renderer.js';
import { Controls } from './controls.js';
import { WorkerPool } from './worker-pool.js';
import { SpatialIndex } from './spatial-index.js';
import { BufferManager } from './buffer-manager.js';
import { TextureAtlas } from './texture-atlas.js';
import { debugLog } from './math-utils.js';
window.DEBUG = DEBUG;
// Main class that ties everything together
class VoxelEngine {
    constructor() {
        // Camera state
        this.camera = {
            position: [0, 20, 0],
            rotation: [0, 0] // [yaw, pitch]
        };

        // Performance tracking
        this.lastFrameTime = 0;
        this.frameCount = 0;
        this.fps = 0;
        this.memoryUsage = 0;
        this.lastMemCheckTime = 0;
        this.initialized = false;
        this.engineReady = false;

        // Add memory usage display element
        this.addPerformanceDisplay();

        // Initialize components
        this.canvas = document.getElementById('glCanvas');
        this.renderer = new Renderer(this.canvas);

        // Create buffer manager
        this.bufferManager = new BufferManager(this.renderer.gl);

        // Set buffer manager in renderer
        this.renderer.setBufferManager(this.bufferManager);

        // Create spatial index
        this.spatialIndex = new SpatialIndex();

        // Create texture atlas - now returns a promise
        this.textureAtlas = new TextureAtlas(this.renderer.gl);

        // Initialize voxel types
        this.voxelTypes = new VoxelTypeManager(this.textureAtlas);

        // Initialize worker pool if multithreading is enabled
        this.workerPool = null;
        this.workerInitPromise = Promise.resolve(); // Default to resolved promise

        if (ENABLE_MULTITHREADING) {
            try {
                this.workerPool = new WorkerPool(WORKER_COUNT);
                console.log(Worker pool initialized with ${this.workerPool.workers.length} workers);

                // The worker initialization is now a promise
                this.workerInitPromise = new Promise((resolve, reject) => {
                    // Only send texture data once the texture atlas is ready
                    this.textureAtlas.loadingPromise.then(() => {
                        if (this.workerPool.workers.length === 0) {
                            console.warn("No workers available for initialization");
                            resolve();
                            return;
                        }

                        this.workerPool.addTask(
                            'initializeTextures',
                            {
                                textureData: this.voxelTypes.getSerializableTextureData()
                            },
                            (result) => {
                                console.log("Texture data sent to workers:", result);
                                resolve();
                            },
                            []
                        );
                    }).catch(err => {
                        console.error("Failed to initialize workers with textures:", err);
                        resolve(); // Still resolve to allow engine to continue
                    });
                });
            } catch (error) {
                console.error("Failed to initialize worker pool:", error);
                // Continue without workers
                this.workerInitPromise = Promise.resolve(); // Make sure we still have a resolved promise
            }
        }

        // Create world generator
        this.worldGenerator = new WorldGenerator();

        // Create mesher
        this.mesher = new Mesher(this.voxelTypes, this.textureAtlas);

        // Create chunk manager
        this.chunkManager = new ChunkManager(
            this.worldGenerator,
            this.mesher,
            this.renderer,
            this.workerPool,
            this.spatialIndex,
            this.bufferManager
        );

        // Create controls
        this.controls = new Controls(this.canvas, this.camera, this.chunkManager);

        // Set up resize handler
        window.addEventListener('resize', this.handleResize.bind(this));

        // Initialize the engine
        this.initEngine();
    }

    // Initialize the engine with proper async handling
    async initEngine() {
        try {
            // Wait for both texture loading and worker initialization
            await Promise.all([
                this.textureAtlas.loadingPromise,
                this.workerInitPromise
            ]);

            console.log("Engine initialized successfully");
            this.engineReady = true;

            // Now start the game loop
            requestAnimationFrame(this.render.bind(this));

            // Add enhanced debugging
            this.addEnhancedDebugging();
        } catch (error) {
            console.error("Failed to initialize engine:", error);

            // Try to continue anyway
            this.engineReady = true;
            requestAnimationFrame(this.render.bind(this));
        }
    }

    // Enhanced debugging functionality
    addEnhancedDebugging() {
        // Skip if not in debug mode
        if (!window.DEBUG) return;

        const debugPanel = document.createElement('div');
        debugPanel.style.position = 'fixed';
        debugPanel.style.bottom = '10px';
        debugPanel.style.left = '10px';
        debugPanel.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        debugPanel.style.color = 'white';
        debugPanel.style.padding = '10px';
        debugPanel.style.fontFamily = 'monospace';
        debugPanel.style.fontSize = '12px';
        debugPanel.style.maxHeight = '200px';
        debugPanel.style.overflowY = 'auto';
        debugPanel.style.zIndex = '1000';
        debugPanel.id = 'debug-panel';

        // Add header
        const header = document.createElement('div');
        header.textContent = 'Debug Panel';
        header.style.fontWeight = 'bold';
        header.style.marginBottom = '5px';
        debugPanel.appendChild(header);

        // Add content div
        const content = document.createElement('div');
        content.id = 'debug-content';
        debugPanel.appendChild(content);

        // Add to document
        document.body.appendChild(debugPanel);

        // Log old console methods
        const originalLog = console.log;
        const originalWarn = console.warn;
        const originalError = console.error;

        // Limit the number of messages to keep
        const MAX_MESSAGES = 30;
        const messages = [];

        // Helper to add message to debug panel
        function addMessage(type, args) {
            if (messages.length >= MAX_MESSAGES) {
                messages.shift();
            }

            const msg = document.createElement('div');
            msg.style.marginBottom = '2px';

            // Format the message
            let text = '';
            for (const arg of args) {
                if (typeof arg === 'object') {
                    try {
                        text += JSON.stringify(arg) + ' ';
                    } catch (e) {
                        text += '[Object] ';
                    }
                } else {
                    text += arg + ' ';
                }
            }

            // Set color based on type
            switch (type) {
                case 'log':
                    msg.style.color = 'white';
                    break;
                case 'warn':
                    msg.style.color = 'yellow';
                    break;
                case 'error':
                    msg.style.color = 'red';
                    break;
            }

            // Add timestamp
            const time = new Date().toLocaleTimeString();
            msg.textContent = [${time}] ${text};

            messages.push(msg);

            // Update the panel
            const content = document.getElementById('debug-content');
            if (content) {
                content.innerHTML = '';
                for (const m of messages) {
                    content.appendChild(m.cloneNode(true));
                }
                content.scrollTop = content.scrollHeight;
            }
        }

        // Override console methods
        console.log = function (...args) {
            originalLog.apply(console, args);
            addMessage('log', args);
        };

        console.warn = function (...args) {
            originalWarn.apply(console, args);
            addMessage('warn', args);
        };

        console.error = function (...args) {
            originalError.apply(console, args);
            addMessage('error', args);
        };

        // Add worker, chunk, and buffer stats
        setInterval(() => {
            if (window.voxelEngine && window.voxelEngine.engineReady) {
                const stats = [];

                // Worker stats
                if (window.voxelEngine.workerPool) {
                    const pool = window.voxelEngine.workerPool;
                    stats.push(Workers: ${pool.workers.length} (${pool.idleWorkers.length} idle));
                    stats.push(Tasks: ${pool.taskQueue.length + pool.priorityTaskQueue.length} queued, ${pool.activeTaskCount} active);
                }

                // Chunk stats
                if (window.voxelEngine.chunkManager) {
                    const cm = window.voxelEngine.chunkManager;
                    stats.push(Chunks: ${cm.totalChunks} (${cm.dirtyChunks.size} dirty));
                    stats.push(Load Queue: ${cm.loadQueue.length}, Unload Queue: ${cm.unloadQueue.length});
                    stats.push(Pending Ops: ${cm.pendingOperations.size});
                }

                // Buffer stats
                if (window.voxelEngine.bufferManager) {
                    const bm = window.voxelEngine.bufferManager;
                    const bmStats = bm.getStats();
                    stats.push(Buffers: ${bmStats.active}/${bmStats.created} (${bmStats.reused} reused, ${bmStats.released} released));
                }

                // Update stats in panel
                const content = document.getElementById('debug-content');
                if (content) {
                    const statsDiv = document.createElement('div');
                    statsDiv.style.borderTop = '1px solid #555';
                    statsDiv.style.marginTop = '5px';
                    statsDiv.style.paddingTop = '5px';

                    for (const stat of stats) {
                        const div = document.createElement('div');
                        div.textContent = stat;
                        statsDiv.appendChild(div);
                    }

                    content.appendChild(statsDiv);
                    content.scrollTop = content.scrollHeight;

                    // Trim old messages
                    while (content.childNodes.length > MAX_MESSAGES + 5) {
                        content.removeChild(content.firstChild);
                    }
                }
            }
        }, 1000);

        // Add toggle button
        const toggleButton = document.createElement('button');
        toggleButton.textContent = 'Debug';
        toggleButton.style.position = 'fixed';
        toggleButton.style.bottom = '10px';
        toggleButton.style.right = '10px';
        toggleButton.style.zIndex = '1001';
        toggleButton.style.padding = '5px 10px';
        toggleButton.style.backgroundColor = '#444';
        toggleButton.style.color = 'white';
        toggleButton.style.border = 'none';
        toggleButton.style.borderRadius = '3px';
        toggleButton.onclick = () => {
            debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';
        };
        document.body.appendChild(toggleButton);

        console.log("Enhanced debugging initialized");
    }

    handleResize() {
        this.renderer.resizeCanvasToDisplaySize();
    }

    addPerformanceDisplay() {
        const statsDiv = document.getElementById('stats');
        if (statsDiv) {
            // Add memory usage display
            const memoryElement = document.createElement('p');
            memoryElement.innerHTML = 'Memory: <span id="memory">0</span> MB';
            statsDiv.appendChild(memoryElement);

            // Add octree stats display
            const octreeElement = document.createElement('p');
            octreeElement.innerHTML = 'Nodes: <span id="nodes">0</span>';
            statsDiv.appendChild(octreeElement);

            // Add culling stats display
            const cullingElement = document.createElement('p');
            cullingElement.innerHTML = 'Culled: <span id="culled">0</span>%';
            statsDiv.appendChild(cullingElement);

            // Add threading stats
            const threadingElement = document.createElement('p');
            threadingElement.innerHTML = 'Workers: <span id="workers">0</span> tasks';
            statsDiv.appendChild(threadingElement);

            // Add buffer stats
            const bufferElement = document.createElement('p');
            bufferElement.innerHTML = 'Buffers: <span id="buffers">0</span>';
            statsDiv.appendChild(bufferElement);
        }
    }

    render(now) {
        // Calculate delta time (in seconds)
        const deltaTime = (now - (this.lastTime || now)) / 1000;
        this.lastTime = now;

        // Check if we're fully initialized - safety check
        if (!this.engineReady) {
            console.warn("Engine not fully initialized yet, waiting...");
            requestAnimationFrame(this.render.bind(this));
            return;
        }

        // Calculate FPS
        this.frameCount++;
        if (now - this.lastFrameTime >= 1000) {
            this.fps = Math.round((this.frameCount * 1000) / (now - this.lastFrameTime));
            document.getElementById('fps').textContent = this.fps;
            this.frameCount = 0;
            this.lastFrameTime = now;

            // Update memory usage every second
            try {
                if (window.performance && window.performance.memory) {
                    this.memoryUsage = Math.round(window.performance.memory.usedJSHeapSize / (1024 * 1024));
                    document.getElementById('memory').textContent = this.memoryUsage;
                }
            } catch (e) {
                // Memory API might not be available or accessible
                document.getElementById('memory').textContent = "N/A";
            }

            // Update octree stats
            const nodeCount = this.chunkManager.totalNodes || 0;
            document.getElementById('nodes').textContent = nodeCount;

            // Update worker stats
            if (ENABLE_MULTITHREADING && this.workerPool) {
                const workerTasks = this.workerPool.getTotalTaskCount();
                document.getElementById('workers').textContent = workerTasks;
            } else {
                document.getElementById('workers').textContent = "disabled";
            }

            // Update buffer stats
            const bufferStats = this.bufferManager.getStats();
            document.getElementById('buffers').textContent =
                ${bufferStats.active}/${bufferStats.created} (${bufferStats.reused} reused);
        }

        // Update controls
        this.controls.update(deltaTime);

        // Update worker pool with player position for task prioritization
        if (ENABLE_MULTITHREADING && this.workerPool) {
            this.workerPool.updatePlayerPosition(
                this.camera.position[0],
                this.camera.position[1],
                this.camera.position[2]
            );
        }

        // Update chunks based on camera position
        this.chunkManager.updateChunks(
            this.camera.position[0],
            this.camera.position[1],
            this.camera.position[2]
        );

        // Build/update chunk meshes
        this.chunkManager.buildChunkMeshes();

        // Resize canvas
        this.renderer.resizeCanvasToDisplaySize();

        // Clear the screen
        this.renderer.clear();

        // Set up camera and projection matrices
        const projectionMatrix = mat4.create();
        const fieldOfView = 70 * Math.PI / 180; // Wider FOV for better visibility
        const aspect = this.canvas.clientWidth / this.canvas.clientHeight;
        const zNear = 0.1;
        const zFar = CHUNK_SIZE * (RENDER_DISTANCE + 1) * 1.5;

        mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);

        // Create camera view matrix
        const viewMatrix = mat4.create();
        const forward = [
            Math.sin(this.camera.rotation[0]) * Math.cos(this.camera.rotation[1]),
            Math.sin(this.camera.rotation[1]),
            Math.cos(this.camera.rotation[0]) * Math.cos(this.camera.rotation[1])
        ];

        // Ensure forward vector is normalized
        const forwardLength = Math.sqrt(
            forward[0] * forward[0] +
            forward[1] * forward[1] +
            forward[2] * forward[2]
        );

        if (forwardLength > 0.00001) {
            forward[0] /= forwardLength;
            forward[1] /= forwardLength;
            forward[2] /= forwardLength;
        }

        const target = [
            this.camera.position[0] + forward[0],
            this.camera.position[1] + forward[1],
            this.camera.position[2] + forward[2]
        ];

        const up = [0, 1, 0];
        mat4.lookAt(viewMatrix, this.camera.position, target, up);

        // Bind the texture atlas
        this.textureAtlas.bind(0);

        // Render all chunks
        const drawnChunks = this.chunkManager.render(projectionMatrix, viewMatrix);

        // Update culling stats if available
        if (this.chunkManager.cullStats) {
            const { total, culled } = this.chunkManager.cullStats;
            const cullPercent = total > 0 ? Math.round((culled / total) * 100) : 0;
            document.getElementById('culled').textContent = cullPercent;
        }

        // Request next frame
        requestAnimationFrame(this.render.bind(this));
    }

    // Clean up resources
    dispose() {
        // Terminate workers
        if (this.workerPool) {
            this.workerPool.terminate();
        }

        // Dispose buffer manager
        if (this.bufferManager) {
            this.bufferManager.dispose();
        }

        // Dispose texture atlas
        if (this.textureAtlas) {
            this.textureAtlas.dispose();
        }

        // Dispose renderer
        if (this.renderer) {
            this.renderer.dispose();
        }
    }
}

// Initialize the engine when the page loads
window.onload = () => {
    try {
        window.voxelEngine = new VoxelEngine();

        // Set up cleanup on unload
        window.addEventListener('beforeunload', () => {
            if (window.voxelEngine) {
                window.voxelEngine.dispose();
            }
        });
    } catch (error) {
        console.error("Failed to initialize VoxelEngine:", error);
        // Display error to user
        const errorDiv = document.createElement('div');
        errorDiv.style.position = 'fixed';
        errorDiv.style.top = '50%';
        errorDiv.style.left = '50%';
        errorDiv.style.transform = 'translate(-50%, -50%)';
        errorDiv.style.backgroundColor = 'rgba(255, 0, 0, 0.8)';
        errorDiv.style.color = 'white';
        errorDiv.style.padding = '20px';
        errorDiv.style.borderRadius = '5px';
        errorDiv.style.zIndex = '1000';
        errorDiv.style.maxWidth = '80%';
        errorDiv.style.textAlign = 'center';
        errorDiv.innerHTML = <h3>Error initializing engine</h3><p>${error.message}</p><p>Check console for details.</p>;
        document.body.appendChild(errorDiv);
    }
};</content></file><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/js/math-utils.js</path><content>import { CHUNK_SIZE, DEBUG } from './constants.js';

export const mat4 = {
    create() {
        return new Float32Array([
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        ]);
    },

    perspective(out, fovy, aspect, near, far) {
        const f = 1.0 / Math.tan(fovy / 2);
        out[0] = f / aspect;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = f;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = (far + near) / (near - far);
        out[11] = -1;
        out[12] = 0;
        out[13] = 0;
        out[14] = (2 * far * near) / (near - far);
        out[15] = 0;
        return out;
    },

    lookAt(out, eye, center, up) {
        let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;

        // z = normalized(eye - center)
        z0 = eye[0] - center[0];
        z1 = eye[1] - center[1];
        z2 = eye[2] - center[2];

        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
        z0 *= len;
        z1 *= len;
        z2 *= len;

        // x = normalized(cross(up, z))
        x0 = up[1] * z2 - up[2] * z1;
        x1 = up[2] * z0 - up[0] * z2;
        x2 = up[0] * z1 - up[1] * z0;

        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
        if (!len) {
            x0 = 0;
            x1 = 0;
            x2 = 0;
        } else {
            len = 1 / len;
            x0 *= len;
            x1 *= len;
            x2 *= len;
        }

        // y = cross(z, x)
        y0 = z1 * x2 - z2 * x1;
        y1 = z2 * x0 - z0 * x2;
        y2 = z0 * x1 - z1 * x0;

        out[0] = x0;
        out[1] = y0;
        out[2] = z0;
        out[3] = 0;
        out[4] = x1;
        out[5] = y1;
        out[6] = z1;
        out[7] = 0;
        out[8] = x2;
        out[9] = y2;
        out[10] = z2;
        out[11] = 0;
        out[12] = -(x0 * eye[0] + x1 * eye[1] + x2 * eye[2]);
        out[13] = -(y0 * eye[0] + y1 * eye[1] + y2 * eye[2]);
        out[14] = -(z0 * eye[0] + z1 * eye[1] + z2 * eye[2]);
        out[15] = 1;

        return out;
    },

    invert(out, a) {
        const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
        const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
        const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
        const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

        const b00 = a00 * a11 - a01 * a10;
        const b01 = a00 * a12 - a02 * a10;
        const b02 = a00 * a13 - a03 * a10;
        const b03 = a01 * a12 - a02 * a11;
        const b04 = a01 * a13 - a03 * a11;
        const b05 = a02 * a13 - a03 * a12;
        const b06 = a20 * a31 - a21 * a30;
        const b07 = a20 * a32 - a22 * a30;
        const b08 = a20 * a33 - a23 * a30;
        const b09 = a21 * a32 - a22 * a31;
        const b10 = a21 * a33 - a23 * a31;
        const b11 = a22 * a33 - a23 * a32;

        // Calculate the determinant
        let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

        if (!det) {
            return null;
        }
        det = 1.0 / det;

        out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
        out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
        out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
        out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
        out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
        out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
        out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
        out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
        out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
        out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
        out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
        out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
        out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
        out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
        out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
        out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

        return out;
    },

    translate(out, a, v) {
        const x = v[0], y = v[1], z = v[2];

        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];

        return out;
    },

    multiply(out, a, b) {
        const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
        const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
        const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
        const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

        let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
        out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
        out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
        out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
        out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        return out;
    },

    transpose(out, a) {
        if (out === a) {
            const a01 = a[1], a02 = a[2], a03 = a[3];
            const a12 = a[6], a13 = a[7];
            const a23 = a[11];

            out[1] = a[4];
            out[2] = a[8];
            out[3] = a[12];
            out[4] = a01;
            out[6] = a[9];
            out[7] = a[13];
            out[8] = a02;
            out[9] = a12;
            out[11] = a[14];
            out[12] = a03;
            out[13] = a13;
            out[14] = a23;
        } else {
            out[0] = a[0];
            out[1] = a[4];
            out[2] = a[8];
            out[3] = a[12];
            out[4] = a[1];
            out[5] = a[5];
            out[6] = a[9];
            out[7] = a[13];
            out[8] = a[2];
            out[9] = a[6];
            out[10] = a[10];
            out[11] = a[14];
            out[12] = a[3];
            out[13] = a[7];
            out[14] = a[11];
            out[15] = a[15];
        }

        return out;
    },

    frustumFromMatrix(projectionViewMatrix) {
        const frustum = {
            planes: [
                new Float32Array(4), // Left
                new Float32Array(4), // Right
                new Float32Array(4), // Bottom
                new Float32Array(4), // Top
                new Float32Array(4), // Near
                new Float32Array(4)  // Far
            ]
        };

        // Column 1
        const m0 = projectionViewMatrix[0];
        const m1 = projectionViewMatrix[1];
        const m2 = projectionViewMatrix[2];
        const m3 = projectionViewMatrix[3];

        // Column 2
        const m4 = projectionViewMatrix[4];
        const m5 = projectionViewMatrix[5];
        const m6 = projectionViewMatrix[6];
        const m7 = projectionViewMatrix[7];

        // Column 3
        const m8 = projectionViewMatrix[8];
        const m9 = projectionViewMatrix[9];
        const m10 = projectionViewMatrix[10];
        const m11 = projectionViewMatrix[11];

        // Column 4
        const m12 = projectionViewMatrix[12];
        const m13 = projectionViewMatrix[13];
        const m14 = projectionViewMatrix[14];
        const m15 = projectionViewMatrix[15];

        // Left plane (m3 + m0)
        frustum.planes[0][0] = m3 + m0;
        frustum.planes[0][1] = m7 + m4;
        frustum.planes[0][2] = m11 + m8;
        frustum.planes[0][3] = m15 + m12;

        // Right plane (m3 - m0)
        frustum.planes[1][0] = m3 - m0;
        frustum.planes[1][1] = m7 - m4;
        frustum.planes[1][2] = m11 - m8;
        frustum.planes[1][3] = m15 - m12;

        // Bottom plane (m3 + m1)
        frustum.planes[2][0] = m3 + m1;
        frustum.planes[2][1] = m7 + m5;
        frustum.planes[2][2] = m11 + m9;
        frustum.planes[2][3] = m15 + m13;

        // Top plane (m3 - m1)
        frustum.planes[3][0] = m3 - m1;
        frustum.planes[3][1] = m7 - m5;
        frustum.planes[3][2] = m11 - m9;
        frustum.planes[3][3] = m15 - m13;

        // Near plane (m3 + m2)
        frustum.planes[4][0] = m3 + m2;
        frustum.planes[4][1] = m7 + m6;
        frustum.planes[4][2] = m11 + m10;
        frustum.planes[4][3] = m15 + m14;

        // Far plane (m3 - m2)
        frustum.planes[5][0] = m3 - m2;
        frustum.planes[5][1] = m7 - m6;
        frustum.planes[5][2] = m11 - m10;
        frustum.planes[5][3] = m15 - m14;

        // Normalize planes
        for (let i = 0; i < 6; i++) {
            const plane = frustum.planes[i];
            const length = Math.sqrt(
                plane[0] * plane[0] +
                plane[1] * plane[1] +
                plane[2] * plane[2]
            );

            // Only normalize if length is not zero
            if (length > 0.00001) {
                plane[0] /= length;
                plane[1] /= length;
                plane[2] /= length;
                plane[3] /= length;
            }
        }

        return frustum;
    },

    // Check if bounding box is in frustum
    isBoxInFrustum(frustum, minX, minY, minZ, maxX, maxY, maxZ) {
        for (let i = 0; i < 6; i++) {
            const plane = frustum.planes[i];

            // Find the point furthest along the normal direction (positive vertex)
            let px = plane[0] >= 0 ? maxX : minX;
            let py = plane[1] >= 0 ? maxY : minY;
            let pz = plane[2] >= 0 ? maxZ : minZ;

            // If the furthest point is outside, the box is outside
            const d = plane[0] * px + plane[1] * py + plane[2] * pz + plane[3];
            if (d < 0) {
                return false;
            }
        }

        return true;
    }
};

export function normalizeVector(v) {
    const length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
    if (length === 0) return v;

    v[0] /= length;
    v[1] /= length;
    v[2] /= length;
    return v;
}

export function debugLog(message) {
    if (DEBUG) {
        console.log(message);
    }
}</content></file><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/js/mesher.js</path><content>import { CHUNK_SIZE } from './constants.js';
import { debugLog } from './math-utils.js';
import { VoxelType } from './voxel-types.js';

export class Mesher {
    constructor(voxelTypeManager) {
        this.voxelTypes = voxelTypeManager;
    }

    // Generate mesh using greedy meshing algorithm
    generateMesh(chunk, chunkX, chunkY, chunkZ, getNeighborChunk) {
        const positions = [];
        const normals = [];
        const colors = [];
        const indices = [];
        let indexOffset = 0;

        // Skip if chunk is empty
        if (chunk.isEmpty()) {
            return { positions, normals, colors, indices };
        }

        // For each of the 3 axis directions
        for (let dim = 0; dim < 3; dim++) {
            // Setup axes based on current dimension
            const u = (dim + 1) % 3;
            const v = (dim + 2) % 3;
            const w = dim;

            // Direction vectors for u, v, w
            const uDir = [0, 0, 0];
            const vDir = [0, 0, 0];
            const wDir = [0, 0, 0];

            uDir[u] = 1;
            vDir[v] = 1;
            wDir[w] = 1;

            // Face names and normals based on dimension and direction
            const posDirection = ['right', 'top', 'front']; // +X, +Y, +Z
            const negDirection = ['left', 'bottom', 'back']; // -X, -Y, -Z
            const posNormals = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; // +X, +Y, +Z
            const negNormals = [[-1, 0, 0], [0, -1, 0], [0, 0, -1]]; // -X, -Y, -Z

            // Iterate through each slice of the dimension
            for (let wValue = 0; wValue < CHUNK_SIZE; wValue++) {
                // Two masks for each direction (positive and negative)
                const maskPos = Array(CHUNK_SIZE + 1).fill().map(() =>
                    Array(CHUNK_SIZE + 1).fill({ voxelType: 0, transparent: true, visible: false })
                );

                const maskNeg = Array(CHUNK_SIZE + 1).fill().map(() =>
                    Array(CHUNK_SIZE + 1).fill({ voxelType: 0, transparent: true, visible: false })
                );

                // Fill both masks for this slice
                for (let vValue = 0; vValue < CHUNK_SIZE; vValue++) {
                    for (let uValue = 0; uValue < CHUNK_SIZE; uValue++) {
                        // Set coordinates based on current dimension
                        const x1 = (dim === 0) ? wValue : ((dim === 1) ? uValue : uValue);
                        const y1 = (dim === 0) ? uValue : ((dim === 1) ? wValue : vValue);
                        const z1 = (dim === 0) ? vValue : ((dim === 1) ? vValue : wValue);

                        // Get current voxel
                        const voxel = chunk.getVoxel(x1, y1, z1);
                        const isTransparent1 = this.voxelTypes.isTransparent(voxel);

                        // Get adjacent voxel in positive direction
                        let x2 = x1 + wDir[0];
                        let y2 = y1 + wDir[1];
                        let z2 = z1 + wDir[2];

                        let voxelPos;

                        // Check if the adjacent voxel is in another chunk
                        if (x2 < 0 || x2 >= CHUNK_SIZE || y2 < 0 || y2 >= CHUNK_SIZE || z2 < 0 || z2 >= CHUNK_SIZE) {
                            // Calculate neighbor chunk coordinates
                            let neighborChunkX = chunkX;
                            let neighborChunkY = chunkY;
                            let neighborChunkZ = chunkZ;

                            if (x2 < 0) {
                                neighborChunkX--;
                                x2 += CHUNK_SIZE;
                            } else if (x2 >= CHUNK_SIZE) {
                                neighborChunkX++;
                                x2 -= CHUNK_SIZE;
                            }

                            if (y2 < 0) {
                                neighborChunkY--;
                                y2 += CHUNK_SIZE;
                            } else if (y2 >= CHUNK_SIZE) {
                                neighborChunkY++;
                                y2 -= CHUNK_SIZE;
                            }

                            if (z2 < 0) {
                                neighborChunkZ--;
                                z2 += CHUNK_SIZE;
                            } else if (z2 >= CHUNK_SIZE) {
                                neighborChunkZ++;
                                z2 -= CHUNK_SIZE;
                            }

                            // Get neighbor chunk with safer handling
                            const neighborChunk = getNeighborChunk(neighborChunkX, neighborChunkY, neighborChunkZ);

                            // Add more detailed logging for debugging
                            if (!neighborChunk && console && console.debug) {
                                console.debug(Missing neighbor chunk at ${neighborChunkX},${neighborChunkY},${neighborChunkZ} from ${chunkX},${chunkY},${chunkZ});
                            }

                            voxelPos = neighborChunk ? neighborChunk.getVoxel(x2, y2, z2) : 0;
                        } else {
                            voxelPos = chunk.getVoxel(x2, y2, z2);
                        }

                        const isTransparent2 = this.voxelTypes.isTransparent(voxelPos);

                        // Determine if faces should be created
                        // For positive direction: current solid, next transparent
                        if (voxel !== 0 && (voxelPos === 0 || (isTransparent2 && !isTransparent1))) {
                            maskPos[vValue][uValue] = {
                                voxelType: voxel,
                                transparent: isTransparent1,
                                visible: true
                            };
                        }

                        // For negative direction: current transparent, next solid
                        if (voxelPos !== 0 && (voxel === 0 || (!isTransparent2 && isTransparent1))) {
                            maskNeg[vValue][uValue] = {
                                voxelType: voxelPos,
                                transparent: isTransparent2,
                                visible: true
                            };
                        }
                    }
                }

                // Greedy mesh algorithm for positive direction
                indexOffset = this.greedyMeshDirection(
                    maskPos, dim, wValue, wDir, uDir, vDir, posDirection[dim],
                    posNormals[dim], positions, normals, colors, indices, indexOffset
                );

                // Greedy mesh algorithm for negative direction
                indexOffset = this.greedyMeshDirection(
                    maskNeg, dim, wValue, wDir, uDir, vDir, negDirection[dim],
                    negNormals[dim], positions, normals, colors, indices, indexOffset
                );
            }
        }

        return {
            positions,
            normals,
            colors,
            indices
        };
    }

    // Greedy mesh algorithm for a single direction
    greedyMeshDirection(mask, dim, wValue, wDir, uDir, vDir, faceName, normal, positions, normals, colors, indices, indexOffset) {
        const size = CHUNK_SIZE;

        // Create a visited mask
        const visited = Array(size).fill().map(() => Array(size).fill(false));

        // For each position in the slice
        for (let vStart = 0; vStart < size; vStart++) {
            for (let uStart = 0; uStart < size; uStart++) {
                // Skip if already visited or not visible
                if (visited[vStart][uStart] || !mask[vStart][uStart].visible) {
                    continue;
                }

                // Get voxel type at this position
                const voxelType = mask[vStart][uStart].voxelType;

                // Find maximum width (u direction)
                let uEnd = uStart;
                while (uEnd + 1 < size &&
                    !visited[vStart][uEnd + 1] &&
                    mask[vStart][uEnd + 1].visible &&
                    mask[vStart][uEnd + 1].voxelType === voxelType) {
                    uEnd++;
                }

                // Find maximum height (v direction)
                let vEnd = vStart;
                let canExpandV = true;

                while (vEnd + 1 < size && canExpandV) {
                    // Check if the entire row can be used
                    for (let u = uStart; u <= uEnd; u++) {
                        if (visited[vEnd + 1][u] ||
                            !mask[vEnd + 1][u].visible ||
                            mask[vEnd + 1][u].voxelType !== voxelType) {
                            canExpandV = false;
                            break;
                        }
                    }

                    if (canExpandV) {
                        vEnd++;
                    }
                }

                // Mark all cells in this quad as visited
                for (let v = vStart; v <= vEnd; v++) {
                    for (let u = uStart; u <= uEnd; u++) {
                        visited[v][u] = true;
                    }
                }

                // Create the quad for this merged face
                const width = uEnd - uStart + 1;
                const height = vEnd - vStart + 1;

                // Calculate corner positions based on dimension
                let x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4;

                // Set the w coordinate
                const w = wValue + (dim === 0 ? wDir[0] : 0) + (dim === 1 ? wDir[1] : 0) + (dim === 2 ? wDir[2] : 0);

                // Determine coordinates based on dimension
                if (dim === 0) { // X dimension
                    // Order: bottom-left, bottom-right, top-right, top-left
                    x1 = x2 = x3 = x4 = w;
                    z1 = vStart;
                    y1 = uStart;
                    z2 = vStart;
                    y2 = uStart + width;
                    z3 = vStart + height;
                    y3 = uStart + width;
                    z4 = vStart + height;
                    y4 = uStart;
                } else if (dim === 1) { // Y dimension
                    y1 = y2 = y3 = y4 = w;
                    x1 = uStart;
                    z1 = vStart;
                    x2 = uStart + width;
                    z2 = vStart;
                    x3 = uStart + width;
                    z3 = vStart + height;
                    x4 = uStart;
                    z4 = vStart + height;
                } else { // Z dimension
                    z1 = z2 = z3 = z4 = w;
                    x1 = uStart;
                    y1 = vStart;
                    x2 = uStart + width;
                    y2 = vStart;
                    x3 = uStart + width;
                    y3 = vStart + height;
                    x4 = uStart;
                    y4 = vStart + height;
                }

                // Get color from voxel type manager
                const color = this.voxelTypes.getColor(voxelType, faceName);

                // Simple directional shading
                const shade = 1.0 - 0.2 * Math.abs(dim);
                const finalColor = [
                    color[0] * shade,
                    color[1] * shade,
                    color[2] * shade,
                    color[3]
                ];

                // Add vertices for this quad
                positions.push(
                    x1, y1, z1,
                    x2, y2, z2,
                    x3, y3, z3,
                    x4, y4, z4
                );

                // Add normals
                for (let i = 0; i < 4; i++) {
                    normals.push(normal[0], normal[1], normal[2]);
                }

                // Add colors
                for (let i = 0; i < 4; i++) {
                    colors.push(...finalColor);
                }

                // Add indices (two triangles)
                indices.push(
                    indexOffset, indexOffset + 1, indexOffset + 2,
                    indexOffset, indexOffset + 2, indexOffset + 3
                );

                indexOffset += 4;
            }
        }

        return indexOffset;
    }
}</content></file><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/js/renderer.js</path><content>import { DEBUG, ENABLE_FRUSTUM_CULLING, DEBUG_FRUSTUM_CULLING } from './constants.js';
import { mat4, debugLog } from './math-utils.js';
import { CHUNK_SIZE, RENDER_DISTANCE } from './constants.js';

export class Renderer {
    constructor(canvas) {
        this.canvas = canvas;
        this.gl = canvas.getContext('webgl');
        this.bufferManager = null; // Will be set by main.js

        if (!this.gl) {
            throw new Error('WebGL not supported');
        }

        this.programInfo = null;
        this.texturedProgramInfo = null;
        this.currentFrustum = null;
        this.initWebGL();
    }

    // Set the buffer manager
    setBufferManager(bufferManager) {
        this.bufferManager = bufferManager;
    }

    // Initialize WebGL
    initWebGL() {
        // Create basic shaders for colored voxels
        const vsSource = 
            attribute vec4 aVertexPosition;
            attribute vec3 aVertexNormal;
            attribute vec4 aVertexColor;

            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform mat4 uNormalMatrix;

            varying highp vec3 vNormal;
            varying highp vec4 vColor;
            varying highp vec3 vPosition;

            void main(void) {
                gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
                vNormal = (uNormalMatrix * vec4(aVertexNormal, 0.0)).xyz;
                vColor = aVertexColor;
                vPosition = (uModelViewMatrix * aVertexPosition).xyz;
            }
        ;

        const fsSource = 
            precision highp float;
            
            varying highp vec3 vNormal;
            varying highp vec4 vColor;
            varying highp vec3 vPosition;
            
            uniform vec3 uLightDirection;
            uniform vec3 uViewPosition;
            uniform float uFogNear;
            uniform float uFogFar;
            uniform vec3 uFogColor;
            
            void main(void) {
                // Calculate lighting
                vec3 normal = normalize(vNormal);
                vec3 lightDir = normalize(uLightDirection);
                float diffuse = max(dot(normal, lightDir), 0.0);
                
                // Add ambient light
                float ambient = 0.3;
                float lighting = diffuse + ambient;
                
                // Apply lighting to color (preserve alpha)
                vec4 litColor = vec4(vColor.rgb * lighting, vColor.a);
                
                // Apply fog effect
                float dist = length(vPosition);
                float fogFactor = smoothstep(uFogNear, uFogFar, dist);
                vec3 finalColor = mix(litColor.rgb, uFogColor, fogFactor);
                
                gl_FragColor = vec4(finalColor, litColor.a);
            }
        ;

        // Create textured shader program
        const texturedVsSource = 
            attribute vec4 aVertexPosition;
            attribute vec3 aVertexNormal;
            attribute vec2 aTextureCoord;

            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform mat4 uNormalMatrix;

            varying highp vec3 vNormal;
            varying highp vec2 vTextureCoord;
            varying highp vec3 vPosition;

            void main(void) {
                gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
                vNormal = (uNormalMatrix * vec4(aVertexNormal, 0.0)).xyz;
                vTextureCoord = aTextureCoord;
                vPosition = (uModelViewMatrix * aVertexPosition).xyz;
            }
        ;

        const texturedFsSource = 
            precision highp float;
            
            varying highp vec3 vNormal;
            varying highp vec2 vTextureCoord;
            varying highp vec3 vPosition;
            
            uniform sampler2D uSampler;
            uniform vec3 uLightDirection;
            uniform vec3 uViewPosition;
            uniform float uFogNear;
            uniform float uFogFar;
            uniform vec3 uFogColor;
            
            void main(void) {
                // Get texture color
                vec4 texColor = texture2D(uSampler, vTextureCoord);
                
                // Skip transparent pixels
                if (texColor.a < 0.1) {
                    discard;
                }
                
                // Calculate lighting
                vec3 normal = normalize(vNormal);
                vec3 lightDir = normalize(uLightDirection);
                float diffuse = max(dot(normal, lightDir), 0.0);
                
                // Add ambient light
                float ambient = 0.3;
                float lighting = diffuse + ambient;
                
                // Apply lighting to texture
                vec4 litColor = vec4(texColor.rgb * lighting, texColor.a);
                
                // Apply fog effect
                float dist = length(vPosition);
                float fogFactor = smoothstep(uFogNear, uFogFar, dist);
                vec3 finalColor = mix(litColor.rgb, uFogColor, fogFactor);
                
                gl_FragColor = vec4(finalColor, litColor.a);
            }
        ;

        // Initialize the shader programs
        const shaderProgram = this.initShaderProgram(vsSource, fsSource);
        const texturedShaderProgram = this.initShaderProgram(texturedVsSource, texturedFsSource);

        // Store program info
        this.programInfo = {
            program: shaderProgram,
            attribLocations: {
                vertexPosition: this.gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                vertexNormal: this.gl.getAttribLocation(shaderProgram, 'aVertexNormal'),
                vertexColor: this.gl.getAttribLocation(shaderProgram, 'aVertexColor'),
            },
            uniformLocations: {
                projectionMatrix: this.gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                modelViewMatrix: this.gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
                normalMatrix: this.gl.getUniformLocation(shaderProgram, 'uNormalMatrix'),
                lightDirection: this.gl.getUniformLocation(shaderProgram, 'uLightDirection'),
                viewPosition: this.gl.getUniformLocation(shaderProgram, 'uViewPosition'),
                fogNear: this.gl.getUniformLocation(shaderProgram, 'uFogNear'),
                fogFar: this.gl.getUniformLocation(shaderProgram, 'uFogFar'),
                fogColor: this.gl.getUniformLocation(shaderProgram, 'uFogColor'),
            },
        };

        this.texturedProgramInfo = {
            program: texturedShaderProgram,
            attribLocations: {
                vertexPosition: this.gl.getAttribLocation(texturedShaderProgram, 'aVertexPosition'),
                vertexNormal: this.gl.getAttribLocation(texturedShaderProgram, 'aVertexNormal'),
                textureCoord: this.gl.getAttribLocation(texturedShaderProgram, 'aTextureCoord'),
            },
            uniformLocations: {
                projectionMatrix: this.gl.getUniformLocation(texturedShaderProgram, 'uProjectionMatrix'),
                modelViewMatrix: this.gl.getUniformLocation(texturedShaderProgram, 'uModelViewMatrix'),
                normalMatrix: this.gl.getUniformLocation(texturedShaderProgram, 'uNormalMatrix'),
                sampler: this.gl.getUniformLocation(texturedShaderProgram, 'uSampler'),
                lightDirection: this.gl.getUniformLocation(texturedShaderProgram, 'uLightDirection'),
                viewPosition: this.gl.getUniformLocation(texturedShaderProgram, 'uViewPosition'),
                fogNear: this.gl.getUniformLocation(texturedShaderProgram, 'uFogNear'),
                fogFar: this.gl.getUniformLocation(texturedShaderProgram, 'uFogFar'),
                fogColor: this.gl.getUniformLocation(texturedShaderProgram, 'uFogColor'),
            },
        };

        debugLog('WebGL initialized with shaders');
    }

    // Create a shader program
    initShaderProgram(vsSource, fsSource) {
        const vertexShader = this.loadShader(this.gl.VERTEX_SHADER, vsSource);
        const fragmentShader = this.loadShader(this.gl.FRAGMENT_SHADER, fsSource);

        if (!vertexShader || !fragmentShader) {
            return null;
        }

        const shaderProgram = this.gl.createProgram();
        this.gl.attachShader(shaderProgram, vertexShader);
        this.gl.attachShader(shaderProgram, fragmentShader);
        this.gl.linkProgram(shaderProgram);

        if (!this.gl.getProgramParameter(shaderProgram, this.gl.LINK_STATUS)) {
            console.error('Unable to initialize shader program: ' + this.gl.getProgramInfoLog(shaderProgram));
            return null;
        }

        return shaderProgram;
    }

    // Compile a shader
    loadShader(type, source) {
        const shader = this.gl.createShader(type);
        this.gl.shaderSource(shader, source);
        this.gl.compileShader(shader);

        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            console.error('Shader compilation error: ' + this.gl.getShaderInfoLog(shader));
            this.gl.deleteShader(shader);
            return null;
        }

        return shader;
    }

    // Create a mesh in WebGL using buffer manager
    createMesh(meshData, worldOffset, useTextures = false) {
        const { positions, normals, colors, indices, uvs } = meshData;
        const buffers = {};
        const bufferIds = [];

        // Use buffer manager if available
        if (this.bufferManager) {
            // Create position buffer
            const posBuffer = this.bufferManager.getBuffer('vertex', new Float32Array(positions));
            buffers.position = posBuffer.buffer;
            bufferIds.push(posBuffer.id);

            // Create normal buffer
            const normBuffer = this.bufferManager.getBuffer('normal', new Float32Array(normals));
            buffers.normal = normBuffer.buffer;
            bufferIds.push(normBuffer.id);

            // Create color buffer or UV buffer depending on mode
            if (useTextures && uvs && uvs.length > 0) {
                const uvBuffer = this.bufferManager.getBuffer('uv', new Float32Array(uvs));
                buffers.uv = uvBuffer.buffer;
                bufferIds.push(uvBuffer.id);
                buffers.textured = true;
            } else {
                const colorBuffer = this.bufferManager.getBuffer('color', new Float32Array(colors));
                buffers.color = colorBuffer.buffer;
                bufferIds.push(colorBuffer.id);
                buffers.textured = false;
            }

            // Create index buffer
            const idxBuffer = this.bufferManager.getBuffer('index', new Uint16Array(indices));
            buffers.indices = idxBuffer.buffer;
            bufferIds.push(idxBuffer.id);
        } else {
            // Fallback to direct buffer creation
            // Create position buffer
            const positionBuffer = this.gl.createBuffer();
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);
            buffers.position = positionBuffer;

            // Create normal buffer
            const normalBuffer = this.gl.createBuffer();
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, normalBuffer);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normals), this.gl.STATIC_DRAW);
            buffers.normal = normalBuffer;

            // Create color buffer or UV buffer depending on mode
            if (useTextures && uvs && uvs.length > 0) {
                const uvBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, uvBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(uvs), this.gl.STATIC_DRAW);
                buffers.uv = uvBuffer;
                buffers.textured = true;
            } else {
                const colorBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, colorBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), this.gl.STATIC_DRAW);
                buffers.color = colorBuffer;
                buffers.textured = false;
            }

            // Create index buffer
            const indexBuffer = this.gl.createBuffer();
            this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), this.gl.STATIC_DRAW);
            buffers.indices = indexBuffer;
        }

        // Calculate tight bounds if available
        const bounds = {
            minX: worldOffset[0],
            minY: worldOffset[1],
            minZ: worldOffset[2],
            maxX: worldOffset[0] + CHUNK_SIZE,
            maxY: worldOffset[1] + CHUNK_SIZE,
            maxZ: worldOffset[2] + CHUNK_SIZE
        };

        // Return mesh object
        return {
            buffers,
            bufferIds,  // Store buffer IDs for cleanup
            vertexCount: indices.length,
            worldOffset,
            bounds,
            textured: buffers.textured
        };
    }

    // Delete a mesh
    deleteMesh(mesh) {
        if (!mesh || !mesh.buffers) return;

        if (this.bufferManager && mesh.bufferIds) {
            // Return buffers to pool
            for (const id of mesh.bufferIds) {
                this.bufferManager.releaseBuffer(id);
            }
        } else {
            // Delete buffers directly
            this.gl.deleteBuffer(mesh.buffers.position);
            this.gl.deleteBuffer(mesh.buffers.normal);

            if (mesh.buffers.color) {
                this.gl.deleteBuffer(mesh.buffers.color);
            }

            if (mesh.buffers.uv) {
                this.gl.deleteBuffer(mesh.buffers.uv);
            }

            this.gl.deleteBuffer(mesh.buffers.indices);
        }
    }

    // Resize canvas to match display size
    resizeCanvasToDisplaySize() {
        const displayWidth = this.canvas.clientWidth;
        const displayHeight = this.canvas.clientHeight;

        if (this.canvas.width !== displayWidth || this.canvas.height !== displayHeight) {
            this.canvas.width = displayWidth;
            this.canvas.height = displayHeight;
            this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            return true;
        }
        return false;
    }

    // Clear the screen
    clear() {
        this.gl.clearColor(0.6, 0.8, 1.0, 1.0); // Sky blue
        this.gl.clearDepth(1.0);
        this.gl.enable(this.gl.DEPTH_TEST);
        this.gl.depthFunc(this.gl.LEQUAL);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
    }

    // Check if a mesh is in the view frustum
    isMeshInFrustum(mesh, projViewMatrix) {
        if (!this.currentFrustum) {
            this.currentFrustum = mat4.frustumFromMatrix(projViewMatrix);
        }

        // Get the mesh bounds with a small safety margin to prevent flickering
        const SAFETY_MARGIN = 1.0; // Add 1 unit safety margin
        const bounds = mesh.bounds || {
            minX: mesh.worldOffset[0] - SAFETY_MARGIN,
            minY: mesh.worldOffset[1] - SAFETY_MARGIN,
            minZ: mesh.worldOffset[2] - SAFETY_MARGIN,
            maxX: mesh.worldOffset[0] + CHUNK_SIZE + SAFETY_MARGIN,
            maxY: mesh.worldOffset[1] + CHUNK_SIZE + SAFETY_MARGIN,
            maxZ: mesh.worldOffset[2] + CHUNK_SIZE + SAFETY_MARGIN
        };

        if (mesh.bounds) {
            // Add safety margin to existing bounds
            bounds.minX -= SAFETY_MARGIN;
            bounds.minY -= SAFETY_MARGIN;
            bounds.minZ -= SAFETY_MARGIN;
            bounds.maxX += SAFETY_MARGIN;
            bounds.maxY += SAFETY_MARGIN;
            bounds.maxZ += SAFETY_MARGIN;
        }

        const isInFrustum = mat4.isBoxInFrustum(
            this.currentFrustum,
            bounds.minX, bounds.minY, bounds.minZ,
            bounds.maxX, bounds.maxY, bounds.maxZ
        );

        // Add hysteresis for recently visible meshes to prevent flickering
        if (!isInFrustum && mesh.wasVisible) {
            // If it was visible in the last frame, keep it visible for one more frame
            mesh.visibilityCounter = (mesh.visibilityCounter || 0) + 1;
            if (mesh.visibilityCounter < 3) { // Keep visible for up to 3 frames after going out of view
                return true;
            }
            mesh.wasVisible = false;
            mesh.visibilityCounter = 0;
        } else if (isInFrustum) {
            mesh.wasVisible = true;
            mesh.visibilityCounter = 0;
        }

        return isInFrustum;
    }

    // Render chunks with frustum culling
    renderChunks(meshes, projectionMatrix, viewMatrix) {
        // Set up alpha blending for transparent blocks
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);

        // Create projection-view matrix for frustum culling
        const projViewMatrix = mat4.create();
        mat4.multiply(projViewMatrix, projectionMatrix, viewMatrix);

        // Reset current frustum
        this.currentFrustum = mat4.frustumFromMatrix(projViewMatrix);

        // Draw only visible meshes
        let drawnChunks = 0;
        let skippedChunks = 0;

        // Split meshes into opaque and transparent for proper rendering order
        const opaqueMeshes = [];
        const transparentMeshes = [];

        // Safety counter to detect frustum culling issues
        let visibleCount = 0;

        for (const mesh of meshes) {
            // Skip empty meshes
            if (!mesh || mesh.vertexCount === 0) continue;

            // Skip meshes outside view if frustum culling is enabled
            if (ENABLE_FRUSTUM_CULLING && !this.isMeshInFrustum(mesh, projViewMatrix)) {
                skippedChunks++;
                continue;
            }

            visibleCount++;

            // Sort by transparency
            if (mesh.transparent) {
                transparentMeshes.push(mesh);
            } else {
                opaqueMeshes.push(mesh);
            }
        }

        // Safety check: if no chunks are visible but we have chunks, 
        // the frustum culling might be broken - fallback to rendering all
        if (visibleCount === 0 && meshes.length > 0) {
            console.warn('Frustum culling may have failed - no visible chunks. Rendering all chunks.');
            for (const mesh of meshes) {
                if (!mesh || mesh.vertexCount === 0) continue;

                if (mesh.transparent) {
                    transparentMeshes.push(mesh);
                } else {
                    opaqueMeshes.push(mesh);
                }
            }
        }

        // Draw opaque meshes first
        this.renderMeshGroup(opaqueMeshes, projectionMatrix, viewMatrix);
        drawnChunks += opaqueMeshes.length;

        // Then draw transparent meshes back-to-front
        if (transparentMeshes.length > 0) {
            // Sort transparent meshes by distance from camera (back to front)
            const cameraPosition = [
                -viewMatrix[12],
                -viewMatrix[13],
                -viewMatrix[14]
            ];

            transparentMeshes.sort((a, b) => {
                const aCenter = [
                    a.worldOffset[0] + CHUNK_SIZE / 2,
                    a.worldOffset[1] + CHUNK_SIZE / 2,
                    a.worldOffset[2] + CHUNK_SIZE / 2
                ];
                const bCenter = [
                    b.worldOffset[0] + CHUNK_SIZE / 2,
                    b.worldOffset[1] + CHUNK_SIZE / 2,
                    b.worldOffset[2] + CHUNK_SIZE / 2
                ];

                const aDistSq = Math.pow(aCenter[0] - cameraPosition[0], 2) +
                    Math.pow(aCenter[1] - cameraPosition[1], 2) +
                    Math.pow(aCenter[2] - cameraPosition[2], 2);
                const bDistSq = Math.pow(bCenter[0] - cameraPosition[0], 2) +
                    Math.pow(bCenter[1] - cameraPosition[1], 2) +
                    Math.pow(bCenter[2] - cameraPosition[2], 2);

                return bDistSq - aDistSq; // Back-to-front
            });

            this.renderMeshGroup(transparentMeshes, projectionMatrix, viewMatrix);
            drawnChunks += transparentMeshes.length;
        }

        this.gl.disable(this.gl.BLEND);
        return drawnChunks;
    }

    // Render a group of meshes with the same shader
    renderMeshGroup(meshes, projectionMatrix, viewMatrix) {
        // Skip if no meshes
        if (meshes.length === 0) return;

        // Split meshes by shader type
        const coloredMeshes = meshes.filter(m => !m.textured);
        const texturedMeshes = meshes.filter(m => m.textured);

        // Render colored meshes
        if (coloredMeshes.length > 0) {
            this.gl.useProgram(this.programInfo.program);

            // Set shared uniforms
            this.gl.uniformMatrix4fv(
                this.programInfo.uniformLocations.projectionMatrix,
                false, projectionMatrix);

            this.gl.uniform3fv(
                this.programInfo.uniformLocations.lightDirection,
                [0.5, 1.0, 0.3]);

            // Set camera position for view-dependent effects
            this.gl.uniform3fv(
                this.programInfo.uniformLocations.viewPosition,
                [-viewMatrix[12], -viewMatrix[13], -viewMatrix[14]]);

            // Set fog uniforms
            this.gl.uniform1f(
                this.programInfo.uniformLocations.fogNear,
                CHUNK_SIZE * (RENDER_DISTANCE - 2));
            this.gl.uniform1f(
                this.programInfo.uniformLocations.fogFar,
                CHUNK_SIZE * RENDER_DISTANCE);
            this.gl.uniform3fv(
                this.programInfo.uniformLocations.fogColor,
                [0.6, 0.8, 1.0]); // Sky color

            for (const mesh of coloredMeshes) {
                this.renderColoredMesh(mesh, viewMatrix);
            }
        }

        // Render textured meshes
        if (texturedMeshes.length > 0) {
            this.gl.useProgram(this.texturedProgramInfo.program);

            // Set shared uniforms
            this.gl.uniformMatrix4fv(
                this.texturedProgramInfo.uniformLocations.projectionMatrix,
                false, projectionMatrix);

            this.gl.uniform3fv(
                this.texturedProgramInfo.uniformLocations.lightDirection,
                [0.5, 1.0, 0.3]);

            // Set camera position for view-dependent effects
            this.gl.uniform3fv(
                this.texturedProgramInfo.uniformLocations.viewPosition,
                [-viewMatrix[12], -viewMatrix[13], -viewMatrix[14]]);

            // Set texture sampler
            this.gl.uniform1i(this.texturedProgramInfo.uniformLocations.sampler, 0);

            // Set fog uniforms
            this.gl.uniform1f(
                this.texturedProgramInfo.uniformLocations.fogNear,
                CHUNK_SIZE * (RENDER_DISTANCE - 2));
            this.gl.uniform1f(
                this.texturedProgramInfo.uniformLocations.fogFar,
                CHUNK_SIZE * RENDER_DISTANCE);
            this.gl.uniform3fv(
                this.texturedProgramInfo.uniformLocations.fogColor,
                [0.6, 0.8, 1.0]); // Sky color

            for (const mesh of texturedMeshes) {
                this.renderTexturedMesh(mesh, viewMatrix);
            }
        }
    }

    // Render a colored mesh
    renderColoredMesh(mesh, viewMatrix) {
        // Create model matrix with world offset
        const modelMatrix = mat4.create();
        mat4.translate(modelMatrix, modelMatrix, mesh.worldOffset);

        // Combine with view matrix
        const modelViewMatrix = mat4.create();
        mat4.multiply(modelViewMatrix, viewMatrix, modelMatrix);

        // Normal matrix
        const normalMatrix = mat4.create();
        mat4.invert(normalMatrix, modelViewMatrix);
        mat4.transpose(normalMatrix, normalMatrix);

        // Bind position buffer
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.buffers.position);
        this.gl.vertexAttribPointer(
            this.programInfo.attribLocations.vertexPosition,
            3, this.gl.FLOAT, false, 0, 0);
        this.gl.enableVertexAttribArray(this.programInfo.attribLocations.vertexPosition);

        // Bind normal buffer
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.buffers.normal);
        this.gl.vertexAttribPointer(
            this.programInfo.attribLocations.vertexNormal,
            3, this.gl.FLOAT, false, 0, 0);
        this.gl.enableVertexAttribArray(this.programInfo.attribLocations.vertexNormal);

        // Bind color buffer
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.buffers.color);
        this.gl.vertexAttribPointer(
            this.programInfo.attribLocations.vertexColor,
            4, this.gl.FLOAT, false, 0, 0);
        this.gl.enableVertexAttribArray(this.programInfo.attribLocations.vertexColor);

        // Bind index buffer
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, mesh.buffers.indices);

        // Set uniforms
        this.gl.uniformMatrix4fv(
            this.programInfo.uniformLocations.modelViewMatrix,
            false, modelViewMatrix);
        this.gl.uniformMatrix4fv(
            this.programInfo.uniformLocations.normalMatrix,
            false, normalMatrix);

        // Draw the chunk
        this.gl.drawElements(
            this.gl.TRIANGLES,
            mesh.vertexCount,
            this.gl.UNSIGNED_SHORT,
            0);
    }

    // Render a textured mesh
    renderTexturedMesh(mesh, viewMatrix) {
        // Create model matrix with world offset
        const modelMatrix = mat4.create();
        mat4.translate(modelMatrix, modelMatrix, mesh.worldOffset);

        // Combine with view matrix
        const modelViewMatrix = mat4.create();
        mat4.multiply(modelViewMatrix, viewMatrix, modelMatrix);

        // Normal matrix
        const normalMatrix = mat4.create();
        mat4.invert(normalMatrix, modelViewMatrix);
        mat4.transpose(normalMatrix, normalMatrix);

        // Bind position buffer
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.buffers.position);
        this.gl.vertexAttribPointer(
            this.texturedProgramInfo.attribLocations.vertexPosition,
            3, this.gl.FLOAT, false, 0, 0);
        this.gl.enableVertexAttribArray(this.texturedProgramInfo.attribLocations.vertexPosition);

        // Bind normal buffer
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.buffers.normal);
        this.gl.vertexAttribPointer(
            this.texturedProgramInfo.attribLocations.vertexNormal,
            3, this.gl.FLOAT, false, 0, 0);
        this.gl.enableVertexAttribArray(this.texturedProgramInfo.attribLocations.vertexNormal);

        // Bind UV buffer
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.buffers.uv);
        this.gl.vertexAttribPointer(
            this.texturedProgramInfo.attribLocations.textureCoord,
            2, this.gl.FLOAT, false, 0, 0);
        this.gl.enableVertexAttribArray(this.texturedProgramInfo.attribLocations.textureCoord);

        // Bind index buffer
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, mesh.buffers.indices);

        // Set uniforms
        this.gl.uniformMatrix4fv(
            this.texturedProgramInfo.uniformLocations.modelViewMatrix,
            false, modelViewMatrix);
        this.gl.uniformMatrix4fv(
            this.texturedProgramInfo.uniformLocations.normalMatrix,
            false, normalMatrix);

        // Draw the chunk
        this.gl.drawElements(
            this.gl.TRIANGLES,
            mesh.vertexCount,
            this.gl.UNSIGNED_SHORT,
            0);
    }

    // Clean up resources
    dispose() {
        // No specific cleanup needed for now
    }
}</content></file><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/js/spatial-index.js</path><content>// Spatial index for efficient chunk lookups
import { CHUNK_SIZE, RENDER_DISTANCE } from './constants.js';
import { debugLog, mat4 } from './math-utils.js';

// Spatial hashing constants
const CELL_SIZE = CHUNK_SIZE * 4; // Larger cells for coarse indexing

export class SpatialIndex {
    constructor() {
        // Main spatial hash map
        this.cells = new Map();

        // Secondary indices
        this.chunkToCell = new Map(); // Maps chunk keys to cell keys
        this.allChunks = new Set(); // Set of all chunk keys

        // Statistics
        this.stats = {
            totalChunks: 0,
            totalCells: 0,
            avgChunksPerCell: 0,
            maxChunksPerCell: 0
        };
    }

    // Convert 3D coordinates to cell key
    getCellKey(x, y, z) {
        const cellX = Math.floor(x / CELL_SIZE);
        const cellY = Math.floor(y / CELL_SIZE);
        const cellZ = Math.floor(z / CELL_SIZE);
        return ${cellX},${cellY},${cellZ};
    }

    // Get chunk key from coordinates
    getChunkKey(x, y, z) {
        return ${x},${y},${z};
    }

    // Add a chunk to the spatial index
    addChunk(chunkX, chunkY, chunkZ, chunk) {
        const chunkKey = this.getChunkKey(chunkX, chunkY, chunkZ);

        // Skip if already indexed
        if (this.allChunks.has(chunkKey)) {
            return;
        }

        // Calculate cell coordinates
        const worldX = chunkX * CHUNK_SIZE;
        const worldY = chunkY * CHUNK_SIZE;
        const worldZ = chunkZ * CHUNK_SIZE;
        const cellKey = this.getCellKey(worldX, worldY, worldZ);

        // Add to cell
        if (!this.cells.has(cellKey)) {
            this.cells.set(cellKey, new Set());
            this.stats.totalCells++;
        }

        const cell = this.cells.get(cellKey);
        cell.add(chunkKey);

        // Update secondary indices
        this.chunkToCell.set(chunkKey, cellKey);
        this.allChunks.add(chunkKey);

        // Update stats
        this.stats.totalChunks++;
        this.stats.maxChunksPerCell = Math.max(this.stats.maxChunksPerCell, cell.size);
        this.stats.avgChunksPerCell = this.stats.totalChunks / this.stats.totalCells;
    }

    // Remove a chunk from the spatial index
    removeChunk(chunkX, chunkY, chunkZ) {
        const chunkKey = this.getChunkKey(chunkX, chunkY, chunkZ);

        // Skip if not indexed
        if (!this.allChunks.has(chunkKey)) {
            return;
        }

        // Get cell key
        const cellKey = this.chunkToCell.get(chunkKey);
        if (!cellKey || !this.cells.has(cellKey)) {
            return;
        }

        // Remove from cell
        const cell = this.cells.get(cellKey);
        cell.delete(chunkKey);

        // Remove empty cells
        if (cell.size === 0) {
            this.cells.delete(cellKey);
            this.stats.totalCells--;
        }

        // Update secondary indices
        this.chunkToCell.delete(chunkKey);
        this.allChunks.delete(chunkKey);

        // Update stats
        this.stats.totalChunks--;
        if (this.stats.totalCells > 0) {
            this.stats.avgChunksPerCell = this.stats.totalChunks / this.stats.totalCells;
        } else {
            this.stats.avgChunksPerCell = 0;
        }
    }

    // Check if a chunk exists in the index
    hasChunk(chunkX, chunkY, chunkZ) {
        const chunkKey = this.getChunkKey(chunkX, chunkY, chunkZ);
        return this.allChunks.has(chunkKey);
    }

    // Find chunks within a radius of a point
    findChunksInRadius(worldX, worldY, worldZ, radius) {
        const result = [];
        const radiusSquared = radius * radius;

        // Convert to chunk coordinates
        const centerChunkX = Math.floor(worldX / CHUNK_SIZE);
        const centerChunkY = Math.floor(worldY / CHUNK_SIZE);
        const centerChunkZ = Math.floor(worldZ / CHUNK_SIZE);

        // Calculate cell range to check
        const cellRadius = Math.ceil(radius / CELL_SIZE) + 1;
        const minCellX = Math.floor((worldX - radius) / CELL_SIZE);
        const maxCellX = Math.floor((worldX + radius) / CELL_SIZE);
        const minCellY = Math.floor((worldY - radius) / CELL_SIZE);
        const maxCellY = Math.floor((worldY + radius) / CELL_SIZE);
        const minCellZ = Math.floor((worldZ - radius) / CELL_SIZE);
        const maxCellZ = Math.floor((worldZ + radius) / CELL_SIZE);

        // Check each cell in range
        for (let cellX = minCellX; cellX <= maxCellX; cellX++) {
            for (let cellY = minCellY; cellY <= maxCellY; cellY++) {
                for (let cellZ = minCellZ; cellZ <= maxCellZ; cellZ++) {
                    const cellKey = ${cellX},${cellY},${cellZ};
                    const cell = this.cells.get(cellKey);

                    if (!cell) continue;

                    // Check each chunk in the cell
                    for (const chunkKey of cell) {
                        const [x, y, z] = chunkKey.split(',').map(Number);

                        // Calculate chunk center in world coordinates
                        const chunkCenterX = (x + 0.5) * CHUNK_SIZE;
                        const chunkCenterY = (y + 0.5) * CHUNK_SIZE;
                        const chunkCenterZ = (z + 0.5) * CHUNK_SIZE;

                        // Calculate squared distance
                        const dx = chunkCenterX - worldX;
                        const dy = chunkCenterY - worldY;
                        const dz = chunkCenterZ - worldZ;
                        const distSquared = dx * dx + dy * dy + dz * dz;

                        // Check if within radius
                        if (distSquared <= radiusSquared) {
                            result.push({
                                x, y, z,
                                distanceSquared: distSquared
                            });
                        }
                    }
                }
            }
        }

        // Sort by distance
        result.sort((a, b) => a.distanceSquared - b.distanceSquared);

        return result;
    }

    // Find chunks visible from a position with frustum culling
    findVisibleChunks(viewPosition, frustum) {
        const result = [];

        // Get cells that might be visible
        const cellX = Math.floor(viewPosition[0] / CELL_SIZE);
        const cellY = Math.floor(viewPosition[1] / CELL_SIZE);
        const cellZ = Math.floor(viewPosition[2] / CELL_SIZE);

        // Search range based on render distance
        const searchRange = Math.ceil(RENDER_DISTANCE * CHUNK_SIZE / CELL_SIZE) + 1;

        // Check each potentially visible cell
        for (let x = cellX - searchRange; x <= cellX + searchRange; x++) {
            for (let y = 0; y <= cellY + searchRange; y++) {
                for (let z = cellZ - searchRange; z <= cellZ + searchRange; z++) {
                    const cellKey = ${x},${y},${z};
                    const cell = this.cells.get(cellKey);

                    if (!cell) continue;

                    // Check each chunk in the cell
                    for (const chunkKey of cell) {
                        const [chunkX, chunkY, chunkZ] = chunkKey.split(',').map(Number);

                        // Calculate chunk bounds
                        const minX = chunkX * CHUNK_SIZE;
                        const minY = chunkY * CHUNK_SIZE;
                        const minZ = chunkZ * CHUNK_SIZE;
                        const maxX = minX + CHUNK_SIZE;
                        const maxY = minY + CHUNK_SIZE;
                        const maxZ = minZ + CHUNK_SIZE;

                        // Check if chunk is in frustum using mat4.isBoxInFrustum instead of frustum.isBoxInFrustum
                        if (mat4.isBoxInFrustum(frustum, minX, minY, minZ, maxX, maxY, maxZ)) {
                            result.push({
                                x: chunkX,
                                y: chunkY,
                                z: chunkZ
                            });
                        }
                    }
                }
            }
        }

        return result;
    }

    // Find neighboring chunks
    findNeighbors(chunkX, chunkY, chunkZ) {
        const neighbors = [];

        // Check all 26 possible neighbors
        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dz = -1; dz <= 1; dz++) {
                    if (dx === 0 && dy === 0 && dz === 0) continue;

                    const nx = chunkX + dx;
                    const ny = chunkY + dy;
                    const nz = chunkZ + dz;

                    if (this.hasChunk(nx, ny, nz)) {
                        neighbors.push({ x: nx, y: ny, z: nz });
                    }
                }
            }
        }

        return neighbors;
    }

    // Calculate tight bounding box for a chunk
    calculateTightBounds(chunkX, chunkY, chunkZ, chunk) {
        // Default is full chunk size
        const bounds = {
            minX: 0,
            minY: 0,
            minZ: 0,
            maxX: CHUNK_SIZE - 1,
            maxY: CHUNK_SIZE - 1,
            maxZ: CHUNK_SIZE - 1
        };

        // Skip if chunk doesn't have sparse data
        if (!chunk || !chunk.rootNode) {
            return bounds;
        }

        // Initialize bounds to opposites to find actual bounds
        let minX = CHUNK_SIZE - 1;
        let minY = CHUNK_SIZE - 1;
        let minZ = CHUNK_SIZE - 1;
        let maxX = 0;
        let maxY = 0;
        let maxZ = 0;
        let foundSolid = false;

        // Scan chunk for non-empty voxels
        for (let y = 0; y < CHUNK_SIZE; y++) {
            for (let z = 0; z < CHUNK_SIZE; z++) {
                for (let x = 0; x < CHUNK_SIZE; x++) {
                    const voxel = chunk.getVoxel(x, y, z);
                    if (voxel !== 0) {
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        minZ = Math.min(minZ, z);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                        maxZ = Math.max(maxZ, z);
                        foundSolid = true;
                    }
                }
            }
        }

        // If we found solid voxels, update bounds
        if (foundSolid) {
            bounds.minX = minX;
            bounds.minY = minY;
            bounds.minZ = minZ;
            bounds.maxX = maxX;
            bounds.maxY = maxY;
            bounds.maxZ = maxZ;
        }

        // Convert to world coordinates
        bounds.worldMinX = chunkX * CHUNK_SIZE + bounds.minX;
        bounds.worldMinY = chunkY * CHUNK_SIZE + bounds.minY;
        bounds.worldMinZ = chunkZ * CHUNK_SIZE + bounds.minZ;
        bounds.worldMaxX = chunkX * CHUNK_SIZE + bounds.maxX + 1;
        bounds.worldMaxY = chunkY * CHUNK_SIZE + bounds.maxY + 1;
        bounds.worldMaxZ = chunkZ * CHUNK_SIZE + bounds.maxZ + 1;

        return bounds;
    }
}</content></file><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/js/texture-atlas.js</path><content>// Texture atlas system for efficient texture management
import { VoxelType } from './voxel-types.js';
import { debugLog } from './math-utils.js';

export class TextureAtlas {
    constructor(gl) {
        this.gl = gl;
        this.texture = null;
        this.tileSize = 16;
        this.atlasSize = 256;
        this.tilesPerRow = this.atlasSize / this.tileSize;
        this.textureMap = new Map();
        this.uvCache = new Map();
        this.isLoaded = false;
        this.loadingPromise = null;

        // Create a placeholder texture for use while loading
        this.createPlaceholderTexture();

        // Start loading textures
        this.loadingPromise = this.loadTextures();
    }

    // Create a single-pixel placeholder texture
    createPlaceholderTexture() {
        const gl = this.gl;
        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);

        // Use a single magenta pixel
        const pixel = new Uint8Array([255, 0, 255, 255]);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixel);

        // Set texture parameters
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

        gl.bindTexture(gl.TEXTURE_2D, null);
    }


    // Load textures and create atlas
    async loadTextures() {
        return new Promise((resolve) => {
            // Create a canvas to build the atlas
            const canvas = document.createElement('canvas');
            canvas.width = this.atlasSize;
            canvas.height = this.atlasSize;
            const ctx = canvas.getContext('2d');

            // Fill with placeholder color
            ctx.fillStyle = '#FF00FF'; // Magenta for debugging
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Define and draw texture positions as before...
            const texturePositions = [
                // Format: [voxelType, face, tileX, tileY]
                [VoxelType.GRASS, 'top', 0, 0],
                [VoxelType.GRASS, 'side', 1, 0],
                [VoxelType.GRASS, 'bottom', 2, 0],
                [VoxelType.DIRT, 'all', 2, 0],
                [VoxelType.STONE, 'all', 3, 0],
                [VoxelType.BEDROCK, 'all', 4, 0],
                [VoxelType.WATER, 'all', 5, 0]
            ];

            // Draw textures as before...
            for (const [voxelType, face, tileX, tileY] of texturePositions) {
                // Store and draw textures as in original code...
                // [existing code for drawing textures]

                // Store texture position in map
                const key = this.getTextureKey(voxelType, face);
                this.textureMap.set(key, { tileX, tileY });

                // Draw colored rectangle for this texture
                const x = tileX * this.tileSize;
                const y = tileY * this.tileSize;

                // Get color for this texture from voxel type
                let color;
                switch (voxelType) {
                    case VoxelType.GRASS:
                        if (face === 'top') {
                            color = '#7CFC00'; // Grass top
                        } else if (face === 'side') {
                            color = '#8B4513'; // Grass side
                        } else {
                            color = '#8B4513'; // Dirt
                        }
                        break;
                    case VoxelType.DIRT:
                        color = '#8B4513'; // Dirt
                        break;
                    case VoxelType.STONE:
                        color = '#808080'; // Stone
                        break;
                    case VoxelType.BEDROCK:
                        color = '#383838'; // Bedrock
                        break;
                    case VoxelType.WATER:
                        color = '#0000FF'; // Water
                        break;
                    default:
                        color = '#FF00FF'; // Magenta for missing textures
                }

                // Draw rectangle
                ctx.fillStyle = color;
                ctx.fillRect(x, y, this.tileSize, this.tileSize);

                // Add some texture detail
                if (voxelType === VoxelType.GRASS && face === 'top') {
                    // Add grass pattern
                    ctx.fillStyle = '#90EE90';
                    for (let i = 0; i < 20; i++) {
                        const gx = x + Math.random() * this.tileSize;
                        const gy = y + Math.random() * this.tileSize;
                        ctx.fillRect(gx, gy, 1, 2);
                    }
                } else if (voxelType === VoxelType.STONE) {
                    // Add stone pattern
                    ctx.fillStyle = '#A9A9A9';
                    for (let i = 0; i < 10; i++) {
                        const sx = x + Math.random() * this.tileSize;
                        const sy = y + Math.random() * this.tileSize;
                        const size = 1 + Math.random() * 3;
                        ctx.fillRect(sx, sy, size, size);
                    }
                }
            }

            // Create a texture from the canvas
            this.createTextureFromCanvas(canvas);

            this.isLoaded = true;
            debugLog('TextureAtlas: Created');
            resolve();
        });
    }

    // Create WebGL texture from canvas
    createTextureFromCanvas(canvas) {
        const gl = this.gl;

        // Create and bind texture
        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);

        // Upload the canvas to the texture
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);

        // Set texture parameters
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

        gl.bindTexture(gl.TEXTURE_2D, null);
    }

    // Get texture key for lookups
    getTextureKey(voxelType, face) {
        return ${voxelType}_${face};
    }

    // Get UV coordinates for a voxel type and face
    getUVsForFace(voxelType, face) {
        const cacheKey = this.getTextureKey(voxelType, face);

        // Return from cache if available
        if (this.uvCache.has(cacheKey)) {
            return this.uvCache.get(cacheKey);
        }

        // Look up in texture map
        let texturePos = this.textureMap.get(cacheKey);

        // Fall back to 'all' face if specific face not found
        if (!texturePos) {
            texturePos = this.textureMap.get(this.getTextureKey(voxelType, 'all'));
        }

        // Fall back to default if still not found
        if (!texturePos) {
            texturePos = { tileX: 0, tileY: 0 };
        }

        // Calculate UV coordinates
        const tileSize = this.tileSize;
        const atlasSize = this.atlasSize;

        const u0 = texturePos.tileX * tileSize / atlasSize;
        const v0 = texturePos.tileY * tileSize / atlasSize;
        const u1 = (texturePos.tileX + 1) * tileSize / atlasSize;
        const v1 = (texturePos.tileY + 1) * tileSize / atlasSize;

        const uvs = [
            u0, v0,  // Bottom-left
            u1, v0,  // Bottom-right
            u1, v1,  // Top-right
            u0, v1   // Top-left
        ];

        // Cache the result
        this.uvCache.set(cacheKey, uvs);

        return uvs;
    }

    // Bind the texture atlas for rendering
    bind(textureUnit = 0) {
        const gl = this.gl;
        gl.activeTexture(gl.TEXTURE0 + textureUnit);
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        return textureUnit;
    }

    // Add a method to check if textures are loaded
    isTextureLoaded() {
        return this.isLoaded;
    }

    // Clean up resources
    dispose() {
        if (this.texture) {
            this.gl.deleteTexture(this.texture);
            this.texture = null;
        }

        this.textureMap.clear();
        this.uvCache.clear();

        debugLog('TextureAtlas: Disposed');
    }
}</content></file><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/js/voxel-data.js</path><content>import { CHUNK_SIZE, DEBUG } from './constants.js';
import { debugLog } from './math-utils.js';

// Octree node for efficient voxel storage
class OctreeNode {
    constructor(x, y, z, size) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.size = size;
        this.children = null;
        this.voxelType = 0; // 0 = air/empty
        this.isLeaf = true;
    }

    // Split this node into 8 children
    split() {
        if (this.isLeaf && this.size > 1) {
            this.children = [];
            const halfSize = this.size / 2;

            // Create 8 children nodes
            for (let i = 0; i < 8; i++) {
                const childX = this.x + (i & 1 ? halfSize : 0);
                const childY = this.y + (i & 2 ? halfSize : 0);
                const childZ = this.z + (i & 4 ? halfSize : 0);

                const child = new OctreeNode(childX, childY, childZ, halfSize);
                child.voxelType = this.voxelType; // Inherit parent's type
                this.children.push(child);
            }

            this.isLeaf = false;
        }
    }

    // Try to merge children if they all have the same voxel type
    tryMerge() {
        if (!this.isLeaf && this.children) {
            const firstType = this.children[0].voxelType;
            let allSame = true;

            for (let i = 0; i < 8; i++) {
                if (!this.children[i].isLeaf || this.children[i].voxelType !== firstType) {
                    allSame = false;
                    break;
                }
            }

            if (allSame) {
                this.voxelType = firstType;
                this.children = null;
                this.isLeaf = true;
                return true;
            }
        }
        return false;
    }

    // Get the voxel type at a specific position
    get(x, y, z) {
        // If this is a leaf node, return its type
        if (this.isLeaf) {
            return this.voxelType;
        }

        // Otherwise, find which child contains the position
        const halfSize = this.size / 2;
        const childIndex = ((x >= this.x + halfSize) ? 1 : 0) +
            ((y >= this.y + halfSize) ? 2 : 0) +
            ((z >= this.z + halfSize) ? 4 : 0);

        return this.children[childIndex].get(x, y, z);
    }

    // Set the voxel type at a specific position
    set(x, y, z, voxelType) {
        // Base case: we're at a leaf node of size 1 (single voxel)
        if (this.size === 1) {
            this.voxelType = voxelType;
            return;
        }

        // If this is a leaf but size > 1, we need to split it
        if (this.isLeaf) {
            // No need to split if setting to the same type
            if (this.voxelType === voxelType) {
                return;
            }
            this.split();
        }

        // Find which child contains the position
        const halfSize = this.size / 2;
        const childIndex = ((x >= this.x + halfSize) ? 1 : 0) +
            ((y >= this.y + halfSize) ? 2 : 0) +
            ((z >= this.z + halfSize) ? 4 : 0);

        // Recursively set in the child
        this.children[childIndex].set(x, y, z, voxelType);

        // Try to merge children if possible
        this.tryMerge();
    }

    // Check if the node contains any non-air voxels
    isEmpty() {
        return this.isLeaf && this.voxelType === 0;
    }

    // Visit all leaf nodes with a callback
    visitLeaves(callback) {
        if (this.isLeaf) {
            callback(this);
        } else {
            for (let i = 0; i < 8; i++) {
                this.children[i].visitLeaves(callback);
            }
        }
    }

    // Serialize the node for worker transfer
    serialize() {
        const nodeData = {
            x: this.x,
            y: this.y,
            z: this.z,
            size: this.size,
            voxelType: this.voxelType,
            isLeaf: this.isLeaf
        };

        if (!this.isLeaf && this.children) {
            nodeData.children = this.children.map(child => child.serialize());
        }

        return nodeData;
    }

    // Create node from serialized data
    static deserialize(data) {
        const node = new OctreeNode(data.x, data.y, data.z, data.size);
        node.voxelType = data.voxelType;
        node.isLeaf = data.isLeaf;

        if (!data.isLeaf && data.children) {
            node.children = data.children.map(childData => OctreeNode.deserialize(childData));
        }

        return node;
    }
}

export class Chunk {
    constructor() {
        // Create the root octree node for this chunk
        this.rootNode = new OctreeNode(0, 0, 0, CHUNK_SIZE);
        this.modified = true;
        this.nonEmptyVoxelCount = 0;
    }

    getVoxel(x, y, z) {
        if (x < 0 || x >= CHUNK_SIZE || y < 0 || y >= CHUNK_SIZE || z < 0 || z >= CHUNK_SIZE) {
            return 0; // Out of bounds
        }
        return this.rootNode.get(x, y, z);
    }

    setVoxel(x, y, z, voxelType) {
        if (x < 0 || x >= CHUNK_SIZE || y < 0 || y >= CHUNK_SIZE || z < 0 || z >= CHUNK_SIZE) {
            return; // Out of bounds
        }

        const oldVoxelType = this.getVoxel(x, y, z);
        if (oldVoxelType !== voxelType) {
            this.rootNode.set(x, y, z, voxelType);
            this.modified = true;

            // Update non-empty voxel count
            if (oldVoxelType === 0 && voxelType !== 0) {
                this.nonEmptyVoxelCount++;
            } else if (oldVoxelType !== 0 && voxelType === 0) {
                this.nonEmptyVoxelCount--;
            }
        }
    }

    isEmpty() {
        return this.rootNode.isEmpty();
    }

    // Used for debugging/visualization
    countNodes() {
        let count = 0;

        function countRecursive(node) {
            count++;
            if (!node.isLeaf) {
                for (let i = 0; i < 8; i++) {
                    countRecursive(node.children[i]);
                }
            }
        }

        countRecursive(this.rootNode);
        return count;
    }

    // Fill with array data (for compatibility)
    fillFromArray(voxelData) {
        for (let y = 0; y < CHUNK_SIZE; y++) {
            for (let z = 0; z < CHUNK_SIZE; z++) {
                for (let x = 0; x < CHUNK_SIZE; x++) {
                    const index = (y * CHUNK_SIZE * CHUNK_SIZE) + (z * CHUNK_SIZE) + x;
                    const voxelType = voxelData[index];
                    if (voxelType !== 0) {
                        this.setVoxel(x, y, z, voxelType);
                    }
                }
            }
        }
    }

    // Serialize chunk to flat array for worker transfer
    serialize() {
        const voxelData = new Uint8Array(CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE);

        // Fill array with voxel data
        for (let y = 0; y < CHUNK_SIZE; y++) {
            for (let z = 0; z < CHUNK_SIZE; z++) {
                for (let x = 0; x < CHUNK_SIZE; x++) {
                    const index = (y * CHUNK_SIZE * CHUNK_SIZE) + (z * CHUNK_SIZE) + x;
                    voxelData[index] = this.getVoxel(x, y, z);
                }
            }
        }

        return voxelData;
    }

    // Serialize octree structure for worker transfer
    serializeOctree() {
        return this.rootNode.serialize();
    }

    // Deserialize from octree data
    static deserializeOctree(data) {
        const chunk = new Chunk();
        chunk.rootNode = OctreeNode.deserialize(data);

        // Recalculate non-empty voxel count
        chunk.nonEmptyVoxelCount = 0;

        chunk.rootNode.visitLeaves(node => {
            if (node.voxelType !== 0) {
                // Calculate number of voxels in this leaf node
                const voxelCount = node.size * node.size * node.size;
                chunk.nonEmptyVoxelCount += voxelCount;
            }
        });

        return chunk;
    }
}</content></file><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/js/voxel-types.js</path><content>export const VoxelType = {
    AIR: 0,
    GRASS: 1,
    BEDROCK: 2,
    STONE: 3,
    DIRT: 4,
    WATER: 5
};

export class VoxelTypeManager {
    constructor(textureAtlas = null) {
        this.types = new Map();
        this.textureAtlas = textureAtlas;
        this.useTextures = textureAtlas !== null;
        this.setupDefaultTypes();
    }

    setupDefaultTypes() {
        // Air
        this.registerType(VoxelType.AIR, {
            name: "Air",
            transparent: true,
            solid: false,
            getColor: () => [0, 0, 0, 0],
            textureMapping: {
                all: { tileX: 0, tileY: 0 }
            }
        });

        // Grass
        this.registerType(VoxelType.GRASS, {
            name: "Grass",
            transparent: false,
            solid: true,
            getColor: (face) => {
                if (face === 'top') return [0.3, 0.75, 0.3, 1.0]; // Top - green
                if (face === 'bottom') return [0.5, 0.3, 0.1, 1.0]; // Bottom - dirt color
                return [0.4, 0.5, 0.2, 1.0]; // Sides - grass side
            },
            textureMapping: {
                top: { tileX: 0, tileY: 0 },
                side: { tileX: 1, tileY: 0 },
                bottom: { tileX: 2, tileY: 0 }
            }
        });

        // Bedrock
        this.registerType(VoxelType.BEDROCK, {
            name: "Bedrock",
            transparent: false,
            solid: true,
            getColor: () => [0.2, 0.2, 0.2, 1.0],
            textureMapping: {
                all: { tileX: 4, tileY: 0 }
            }
        });

        // Stone
        this.registerType(VoxelType.STONE, {
            name: "Stone",
            transparent: false,
            solid: true,
            getColor: () => [0.5, 0.5, 0.5, 1.0],
            textureMapping: {
                all: { tileX: 3, tileY: 0 }
            }
        });

        // Dirt
        this.registerType(VoxelType.DIRT, {
            name: "Dirt",
            transparent: false,
            solid: true,
            getColor: () => [0.5, 0.3, 0.1, 1.0],
            textureMapping: {
                all: { tileX: 2, tileY: 0 }
            }
        });

        // Water
        this.registerType(VoxelType.WATER, {
            name: "Water",
            transparent: true,
            solid: true, // Semi-solid for physics
            getColor: () => [0.0, 0.3, 0.8, 0.7],
            textureMapping: {
                all: { tileX: 5, tileY: 0 }
            }
        });
    }

    registerType(id, properties) {
        this.types.set(id, properties);
    }

    getType(id) {
        return this.types.get(id) || this.types.get(VoxelType.AIR);
    }

    isTransparent(id) {
        const type = this.getType(id);
        return type.transparent;
    }

    isSolid(id) {
        const type = this.getType(id);
        return type.solid;
    }

    getColor(id, face) {
        const type = this.getType(id);
        return type.getColor(face);
    }

    // Get texture mapping for a voxel type and face
    getTextureMapping(id, face) {
        const type = this.getType(id);

        if (!type.textureMapping) {
            return null;
        }

        // First check for specific face mapping
        if (type.textureMapping[face]) {
            return type.textureMapping[face];
        }

        // Fall back to 'all' mapping
        if (type.textureMapping.all) {
            return type.textureMapping.all;
        }

        return null;
    }

    // Get serializable texture data for workers
    getSerializableTextureData() {
        const texData = {};

        for (const [id, type] of this.types.entries()) {
            if (type.textureMapping) {
                texData[id] = type.textureMapping;
            }
        }

        return texData;
    }
}</content></file><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/js/worker-manager.js</path><content>// worker-manager.js
// Manages a pool of web workers for offloading heavy tasks

export class WorkerManager {
    constructor(workerCount = navigator.hardwareConcurrency || 4) {
        try {
            if (typeof Worker === 'undefined') {
                console.error('Web Workers are not supported in this browser');
                throw new Error('Web Workers not supported');
            }

            this.workers = [];
            this.taskQueue = [];
            this.availableWorkers = [];
            this.nextTaskId = 0;
            this.taskCallbacks = new Map();

            // Limit workers to a reasonable number
            workerCount = Math.min(workerCount, 4);
            console.log(Initializing ${workerCount} workers);

            // Create worker pool
            for (let i = 0; i < workerCount; i++) {
                this.createWorker();
            }
        } catch (e) {
            console.error('Failed to initialize workers:', e);
            // Continue without workers - engine will be slower but should still work
            this.workersEnabled = false;
        }
    }

    createWorker() {
        // Create worker with inline code instead of trying to load external files
        const workerScript = 
        // Worker variables
        const CHUNK_SIZE = 32;
        const VoxelType = {
            AIR: 0,
            GRASS: 1,
            BEDROCK: 2,
            STONE: 3,
            DIRT: 4,
            WATER: 5,
            SAND: 6
        };
        
        // Create a simple chunk class for the worker
        class WorkerChunk {
            constructor() {
                this.data = new Uint8Array(CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE);
                this.nonEmptyCount = 0;
            }
            
            getVoxel(x, y, z) {
                if (x < 0 || x >= CHUNK_SIZE || y < 0 || y >= CHUNK_SIZE || z < 0 || z >= CHUNK_SIZE) {
                    return 0;
                }
                const index = (y * CHUNK_SIZE * CHUNK_SIZE) + (z * CHUNK_SIZE) + x;
                return this.data[index];
            }
            
            setVoxel(x, y, z, value) {
                if (x < 0 || x >= CHUNK_SIZE || y < 0 || y >= CHUNK_SIZE || z < 0 || z >= CHUNK_SIZE) {
                    return;
                }
                const index = (y * CHUNK_SIZE * CHUNK_SIZE) + (z * CHUNK_SIZE) + x;
                
                if (this.data[index] === 0 && value !== 0) {
                    this.nonEmptyCount++;
                } else if (this.data[index] !== 0 && value === 0) {
                    this.nonEmptyCount--;
                }
                
                this.data[index] = value;
            }
            
            serialize() {
                return {
                    type: 'array',
                    data: this.data.buffer,
                    nonEmptyVoxelCount: this.nonEmptyCount
                };
            }
        }
        
        // Implementation of noise functions
        function noise2D(x, z, seed) {
            return Math.sin(x * 12.9898 + z * 78.233 + seed) * 43758.5453 % 1;
        }
        
        function generateChunkFromSeed(chunkX, chunkY, chunkZ, seed) {
            const chunk = new WorkerChunk();
            const worldX = chunkX * CHUNK_SIZE;
            const worldY = chunkY * CHUNK_SIZE;
            const worldZ = chunkZ * CHUNK_SIZE;
            
            // Special case for the origin chunk
            if (chunkX === 0 && chunkY === 0 && chunkZ === 0) {
                for (let x = 0; x < CHUNK_SIZE; x++) {
                    for (let z = 0; z < CHUNK_SIZE; z++) {
                        // Create a flat platform of stone with grass on top
                        for (let y = 0; y < 10; y++) {
                            chunk.setVoxel(x, y, z, VoxelType.STONE);
                        }
                        chunk.setVoxel(x, 10, z, VoxelType.GRASS);
                    }
                }
                return chunk.serialize();
            }
            
            // Basic terrain generation
            for (let x = 0; x < CHUNK_SIZE; x++) {
                for (let z = 0; z < CHUNK_SIZE; z++) {
                    const wx = worldX + x;
                    const wz = worldZ + z;
                    
                    // Generate a simple height using noise
                    const noiseVal = noise2D(wx * 0.01, wz * 0.01, seed);
                    const height = Math.floor(20 + noiseVal * 10);
                    
                    // Fill voxels up to the height
                    for (let y = 0; y < CHUNK_SIZE; y++) {
                        const wy = worldY + y;
                        if (wy < height) {
                            if (wy < 1) {
                                chunk.setVoxel(x, y, z, VoxelType.BEDROCK);
                            } else if (wy < height - 1) {
                                chunk.setVoxel(x, y, z, VoxelType.STONE);
                            } else {
                                chunk.setVoxel(x, y, z, VoxelType.GRASS);
                            }
                        } else if (wy < 12) { // Water level
                            chunk.setVoxel(x, y, z, VoxelType.WATER);
                        }
                    }
                }
            }
            
            return chunk.serialize();
        }
        
        // Simple mesh generation code
        function generateMeshFromChunk(chunk, chunkX, chunkY, chunkZ, neighbors) {
            // Create a basic mesh with just one cube per voxel
            const positions = [];
            const normals = [];
            const colors = [];
            const indices = [];
            let vertexCount = 0;
            
            // For testing, just create a cube for each non-air voxel
            const chunkData = new Uint8Array(chunk.data);
            for (let y = 0; y < CHUNK_SIZE; y++) {
                for (let z = 0; z < CHUNK_SIZE; z++) {
                    for (let x = 0; x < CHUNK_SIZE; x++) {
                        const index = (y * CHUNK_SIZE * CHUNK_SIZE) + (z * CHUNK_SIZE) + x;
                        const voxelType = chunkData[index];
                        
                        if (voxelType !== 0) {
                            // Add cube at this position (simplified for testing)
                            addCube(positions, normals, colors, indices, x, y, z, voxelType, vertexCount);
                            vertexCount += 24; // 24 vertices for a cube (4 per face * 6 faces)
                        }
                    }
                }
            }
            
            return {
                positions: new Float32Array(positions),
                normals: new Float32Array(normals),
                colors: new Float32Array(colors),
                indices: new Uint16Array(indices)
            };
        }
        
        function addCube(positions, normals, colors, indices, x, y, z, voxelType, startVertex) {
            // Define vertices for a cube centered at the origin with side length 1
            const vertices = [
                // Front face
                x, y, z+1,
                x+1, y, z+1,
                x+1, y+1, z+1,
                x, y+1, z+1,
                
                // Back face
                x+1, y, z,
                x, y, z,
                x, y+1, z,
                x+1, y+1, z,
                
                // Top face
                x, y+1, z,
                x, y+1, z+1,
                x+1, y+1, z+1,
                x+1, y+1, z,
                
                // Bottom face
                x, y, z,
                x+1, y, z,
                x+1, y, z+1,
                x, y, z+1,
                
                // Right face
                x+1, y, z,
                x+1, y, z+1,
                x+1, y+1, z+1,
                x+1, y+1, z,
                
                // Left face
                x, y, z+1,
                x, y, z,
                x, y+1, z,
                x, y+1, z+1
            ];
            
            positions.push(...vertices);
            
            // Add normals
            const normalSets = [
                // Front
                0, 0, 1,
                0, 0, 1,
                0, 0, 1,
                0, 0, 1,
                
                // Back
                0, 0, -1,
                0, 0, -1,
                0, 0, -1,
                0, 0, -1,
                
                // Top
                0, 1, 0,
                0, 1, 0,
                0, 1, 0,
                0, 1, 0,
                
                // Bottom
                0, -1, 0,
                0, -1, 0,
                0, -1, 0,
                0, -1, 0,
                
                // Right
                1, 0, 0,
                1, 0, 0,
                1, 0, 0,
                1, 0, 0,
                
                // Left
                -1, 0, 0,
                -1, 0, 0,
                -1, 0, 0,
                -1, 0, 0
            ];
            
            normals.push(...normalSets);
            
            // Add colors based on voxel type
            let voxelColor;
            
            if (voxelType === 1) { // Grass
                voxelColor = [0.3, 0.75, 0.3, 1.0];
            } else if (voxelType === 2) { // Bedrock
                voxelColor = [0.2, 0.2, 0.2, 1.0];
            } else if (voxelType === 3) { // Stone
                voxelColor = [0.5, 0.5, 0.5, 1.0];
            } else if (voxelType === 4) { // Dirt
                voxelColor = [0.5, 0.3, 0.1, 1.0];
            } else if (voxelType === 5) { // Water
                voxelColor = [0.0, 0.3, 0.8, 0.7];
            } else {
                voxelColor = [1.0, 0.0, 1.0, 1.0]; // Magenta for unknown types
            }
            
            // Add the same color for all vertices of this cube
            for (let i = 0; i < 24; i++) {
                colors.push(...voxelColor);
            }
            
            // Add indices for each of the 6 faces (2 triangles per face)
            for (let face = 0; face < 6; face++) {
                const baseIndex = startVertex + face * 4;
                
                // First triangle of the face
                indices.push(baseIndex, baseIndex + 1, baseIndex + 2);
                
                // Second triangle of the face
                indices.push(baseIndex, baseIndex + 2, baseIndex + 3);
            }
        }
        
        // Handle messages from main thread
        self.onmessage = function(e) {
            const { taskId, taskType, data } = e.data;
            
            let result;
            
            // Process different task types
            if (taskType === 'generateMesh') {
                result = generateMeshFromChunk(data.chunk, data.chunkX, data.chunkY, data.chunkZ, data.neighborChunks);
            } else if (taskType === 'generateChunk') {
                result = generateChunkFromSeed(data.chunkX, data.chunkY, data.chunkZ, data.seed);
            }
            
            // Send result back to main thread
            const transferables = [];
            if (result.positions) transferables.push(result.positions.buffer);
            if (result.normals) transferables.push(result.normals.buffer);
            if (result.colors) transferables.push(result.colors.buffer);
            if (result.indices) transferables.push(result.indices.buffer);
            
            self.postMessage({
                taskId: taskId,
                result: result
            }, transferables);
        };
    ;

        const blob = new Blob([workerScript], { type: 'application/javascript' });
        const worker = new Worker(URL.createObjectURL(blob));

        // Rest of the createWorker function remains the same...
        // Handle worker responses
        worker.onmessage = (e) => {
            const { taskId, result } = e.data;

            // Get and invoke callback
            const callback = this.taskCallbacks.get(taskId);
            if (callback) {
                callback(result);
                this.taskCallbacks.delete(taskId);
            }

            // Mark worker as available and process next task
            this.availableWorkers.push(worker);
            this.processNextTask();
        };

        this.availableWorkers.push(worker);
        this.workers.push(worker);

        return worker;
    }


    // Queue a task for processing
    queueTask(taskType, data, callback) {
        const taskId = this.nextTaskId++;

        this.taskQueue.push({
            taskId,
            taskType,
            data
        });

        this.taskCallbacks.set(taskId, callback);
        this.processNextTask();

        return taskId;
    }

    // Process next task if workers are available
    processNextTask() {
        if (this.taskQueue.length === 0 || this.availableWorkers.length === 0) {
            return;
        }

        const worker = this.availableWorkers.pop();
        const task = this.taskQueue.shift();

        worker.postMessage({
            taskId: task.taskId,
            taskType: task.taskType,
            data: task.data
        });
    }

    // Generate a mesh using workers
    generateMesh(chunk, chunkX, chunkY, chunkZ, neighborChunks, callback) {
        this.queueTask('generateMesh', {
            chunk: chunk.serialize(),
            chunkX,
            chunkY,
            chunkZ,
            neighborChunks: this.serializeNeighborChunks(neighborChunks)
        }, callback);
    }

    // Generate a chunk using workers
    generateChunk(chunkX, chunkY, chunkZ, seed, callback) {
        this.queueTask('generateChunk', {
            chunkX,
            chunkY,
            chunkZ,
            seed
        }, callback);
    }

    // Helper to serialize neighbor chunks for transfer to worker
    serializeNeighborChunks(neighborChunkFunc) {
        // Create a serializable representation of neighbor chunks
        const neighbors = {};

        // Sample neighbors in all directions
        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dz = -1; dz <= 1; dz++) {
                    if (dx === 0 && dy === 0 && dz === 0) continue;

                    const key = ${dx},${dy},${dz};
                    const chunk = neighborChunkFunc(dx, dy, dz);

                    if (chunk) {
                        neighbors[key] = chunk.serialize();
                    }
                }
            }
        }

        return neighbors;
    }

    // Terminate all workers
    terminate() {
        this.workers.forEach(worker => worker.terminate());
        this.workers = [];
        this.availableWorkers = [];
    }
}</content></file><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/js/worker-pool.js</path><content>// Worker pool for multithreaded processing
import { CHUNK_SIZE } from './constants.js';
import { debugLog } from './math-utils.js';

export class WorkerPool {
    constructor(workerCount = navigator.hardwareConcurrency || 4) {
        this.workers = [];
        this.idleWorkers = [];
        this.taskQueue = [];
        this.priorityTaskQueue = [];
        this.taskIdCounter = 0;
        this.callbacks = new Map();
        this.playerPosition = [0, 0, 0];
        this.activeTaskCount = 0;

        // Create workers with better error handling
        for (let i = 0; i < workerCount; i++) {
            try {
                // First try the standard path
                const worker = new Worker('js/worker.js', { type: 'module' });
                this.setupWorker(worker);
            } catch (e) {
                console.warn("Failed to load worker with standard path, trying alternate path:", e);
                try {
                    // Try an alternate path if the first one fails
                    const worker = new Worker('./worker.js', { type: 'module' });
                    this.setupWorker(worker);
                } catch (e2) {
                    console.error("Failed to initialize worker:", e2);
                    // Don't add a worker in this case
                }
            }
        }

        // Log actual number of workers created
        console.log(WorkerPool initialized with ${this.workers.length} workers);
    }
    
    // Update player position for task prioritization
    updatePlayerPosition(x, y, z) {
        this.playerPosition = [x, y, z];
    }

    // Calculate priority based on distance to player
    calculatePriority(chunkX, chunkY, chunkZ) {
        const dx = chunkX * CHUNK_SIZE - this.playerPosition[0];
        const dy = chunkY * CHUNK_SIZE - this.playerPosition[1];
        const dz = chunkZ * CHUNK_SIZE - this.playerPosition[2];

        return dx * dx + dy * dy + dz * dz;
    }

    // Add a task to the queue
    addTask(type, data, callback, transferables = [], priority = false) {
        const taskId = this.taskIdCounter++;

        // Store callback
        this.callbacks.set(taskId, callback);

        const task = {
            taskId,
            type,
            data,
            transferables,
            priority
        };

        // Add priority for chunk tasks
        if (type === 'generateChunk' || type === 'generateMesh') {
            const chunkX = data.chunkX || data.x;
            const chunkY = data.chunkY || data.y;
            const chunkZ = data.chunkZ || data.z;

            // Lower number = higher priority
            task.distancePriority = this.calculatePriority(chunkX, chunkY, chunkZ);
        }

        // Add to appropriate queue
        if (priority) {
            // Insert into priority queue based on distance
            const index = this.priorityTaskQueue.findIndex(t =>
                !t.distancePriority || t.distancePriority > task.distancePriority
            );

            if (index === -1) {
                this.priorityTaskQueue.push(task);
            } else {
                this.priorityTaskQueue.splice(index, 0, task);
            }
        } else {
            this.taskQueue.push(task);
        }

        // Process task immediately if workers are available
        this.processNextTask();
    }

    // Process the next task in the queue
    processNextTask() {
        if (this.idleWorkers.length === 0) return;

        // Get next task (priority queue first)
        const task = this.priorityTaskQueue.shift() || this.taskQueue.shift();
        if (!task) return;

        const worker = this.idleWorkers.pop();

        // Increment active task count
        this.activeTaskCount++;

        // Send task to worker
        worker.postMessage({
            taskId: task.taskId,
            type: task.type,
            data: task.data
        }, task.transferables);
    }

    // Get total tasks (queued + active)
    getTotalTaskCount() {
        return this.taskQueue.length + this.priorityTaskQueue.length + this.activeTaskCount;
    }

    // Terminate all workers (cleanup)
    terminate() {
        for (const worker of this.workers) {
            worker.terminate();
        }
        this.workers = [];
        this.idleWorkers = [];
        this.taskQueue = [];
        this.priorityTaskQueue = [];
        this.callbacks.clear();
    }
    // Helper method to set up a worker
    setupWorker(worker) {
        worker.onmessage = (e) => {
            // Handle multiple possible message formats
            let taskId, result;

            if (e.data.taskId !== undefined) {
                taskId = e.data.taskId;
                // Handle worker.js format where result is in data
                result = e.data.data || e.data.result;
            } else {
                console.error("Received message without taskId:", e.data);
                return;
            }

            // Execute callback for this task
            if (this.callbacks.has(taskId)) {
                const callback = this.callbacks.get(taskId);
                callback(result);
                this.callbacks.delete(taskId);
            } else {
                console.warn(No callback found for task ${taskId});
            }

            // Decrement active task count
            this.activeTaskCount--;

            // Return worker to idle pool
            this.idleWorkers.push(worker);

            // Process next task if available
            this.processNextTask();
        };

        // Add error handler
        worker.onerror = (err) => {
            console.error("Worker error:", err);

            // Put the worker back in the idle pool
            // (May want to restart it instead depending on the error)
            this.idleWorkers.push(worker);
            this.activeTaskCount--;
        };

        this.idleWorkers.push(worker);
        this.workers.push(worker);
    }
}</content></file><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/js/worker.js</path><content>// Worker thread for voxel engine processing
// Import required modules
import { CHUNK_SIZE, MAX_HEIGHT } from './constants.js';
import { VoxelType } from './voxel-types.js';

// Cache for noise functions and other computations
const noiseCache = new Map();
let seed = Math.random() * 10000;

// Texture data storage for worker
let textureData = {};

// Initialize worker
console.log('Voxel Engine Worker initialized');

// Message handler
self.onmessage = function (e) {
    const { taskId, type, data } = e.data;

    let result;
    let transferables = [];

    try {
        switch (type) {
            case 'initializeTextures':
                textureData = data.textureData;
                result = { success: true };
                break;

            case 'generateChunk':
                result = generateChunk(data);
                // If result has a buffer for transferring, add it to transferables
                if (result.buffer) {
                    transferables.push(result.buffer);
                }
                break;

            case 'generateMesh':
                result = generateMesh(data);
                // Add buffer for zero-copy transfer
                if (result.vertexBuffer) {
                    transferables.push(result.vertexBuffer.buffer);
                }
                if (result.normalBuffer) {
                    transferables.push(result.normalBuffer.buffer);
                }
                if (result.colorBuffer) {
                    transferables.push(result.colorBuffer.buffer);
                }
                if (result.indexBuffer) {
                    transferables.push(result.indexBuffer.buffer);
                }
                if (result.uvBuffer) {
                    transferables.push(result.uvBuffer.buffer);
                }
                break;

            case 'createCrater':
                result = createCrater(data);
                break;

            case 'setSeed':
                seed = data.seed;
                result = { success: true };
                break;

            default:
                throw new Error(Unknown task type: ${type});
        }

        // Send result back to main thread
        self.postMessage({
            taskId,
            type,
            data: result,
            transferables
        }, transferables);

    } catch (error) {
        // Send error back to main thread
        self.postMessage({
            taskId,
            type,
            error: error.message
        });
    }
};

// Chunk generation function
function generateChunk(data) {
    const { chunkX, chunkY, chunkZ } = data;

    // Create serializable chunk data
    const voxelData = new Uint8Array(CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE);

    // Calculate world position of chunk
    const worldX = chunkX * CHUNK_SIZE;
    const worldY = chunkY * CHUNK_SIZE;
    const worldZ = chunkZ * CHUNK_SIZE;

    // Generate terrain
    for (let x = 0; x < CHUNK_SIZE; x++) {
        for (let z = 0; z < CHUNK_SIZE; z++) {
            // World coordinates
            const wx = worldX + x;
            const wz = worldZ + z;

            // Generate a height value using noise
            const baseHeight = getHeight(wx, wz);

            // Fill voxels up to the height
            for (let y = 0; y < CHUNK_SIZE; y++) {
                const wy = worldY + y;
                const index = (y * CHUNK_SIZE * CHUNK_SIZE) + (z * CHUNK_SIZE) + x;

                // Determine voxel type based on height
                let voxelType = VoxelType.AIR;

                if (wy < baseHeight) {
                    // Below surface
                    if (wy < 1) {
                        voxelType = VoxelType.BEDROCK;
                    } else if (wy < baseHeight - 5) {
                        voxelType = VoxelType.STONE;
                    } else if (wy < baseHeight - 1) {
                        voxelType = VoxelType.DIRT;
                    } else {
                        voxelType = VoxelType.GRASS;
                    }

                    // Cave generation
                    if (voxelType !== VoxelType.BEDROCK && getCaveNoise(wx, wy, wz) > 0.7) {
                        voxelType = VoxelType.AIR;
                    }
                } else if (wy < 8) {
                    // Water
                    voxelType = VoxelType.WATER;
                }

                voxelData[index] = voxelType;
            }
        }
    }

    return {
        chunkX,
        chunkY,
        chunkZ,
        voxelData,
        buffer: voxelData.buffer
    };
}

// Mesh generation function for worker
function generateMesh(data) {
    const { chunkData, x, y, z, neighbors } = data;

    // Convert flattened data into a format we can work with
    const chunk = {
        getVoxel: function (lx, ly, lz) {
            if (lx < 0 || lx >= CHUNK_SIZE || ly < 0 || ly >= CHUNK_SIZE || lz < 0 || lz >= CHUNK_SIZE) {
                // Try to get voxel from neighbor chunks
                for (const neighbor of neighbors) {
                    if ((lx < 0 && neighbor.x === x - 1) ||
                        (lx >= CHUNK_SIZE && neighbor.x === x + 1) ||
                        (ly < 0 && neighbor.y === y - 1) ||
                        (ly >= CHUNK_SIZE && neighbor.y === y + 1) ||
                        (lz < 0 && neighbor.z === z - 1) ||
                        (lz >= CHUNK_SIZE && neighbor.z === z + 1)) {

                        // Convert coordinates to neighbor's local space
                        let nx = lx, ny = ly, nz = lz;
                        if (lx < 0) nx = CHUNK_SIZE + lx;
                        else if (lx >= CHUNK_SIZE) nx = lx - CHUNK_SIZE;

                        if (ly < 0) ny = CHUNK_SIZE + ly;
                        else if (ly >= CHUNK_SIZE) ny = ly - CHUNK_SIZE;

                        if (lz < 0) nz = CHUNK_SIZE + lz;
                        else if (lz >= CHUNK_SIZE) nz = lz - CHUNK_SIZE;

                        // Get voxel from neighbor data
                        const index = (ny * CHUNK_SIZE * CHUNK_SIZE) + (nz * CHUNK_SIZE) + nx;
                        return neighbor.voxelData[index];
                    }
                }
                return 0; // Default to air if no neighbor found
            }

            const index = (ly * CHUNK_SIZE * CHUNK_SIZE) + (lz * CHUNK_SIZE) + lx;
            return chunkData[index];
        }
    };

    // Generate mesh data
    const positions = [];
    const normals = [];
    const colors = [];
    const indices = [];
    const uvs = [];
    let indexOffset = 0;

    // Implementation of greedy meshing algorithm similar to mesher.js
    // This is a simplified version for the worker

    // Helper functions for meshing
    function isTransparent(voxelType) {
        return voxelType === 0 || voxelType === VoxelType.WATER;
    }

    function getColor(voxelType, face) {
        // Color lookup based on voxel type and face
        switch (voxelType) {
            case VoxelType.GRASS:
                if (face === 'top') return [0.3, 0.75, 0.3, 1.0];
                if (face === 'bottom') return [0.5, 0.3, 0.1, 1.0];
                return [0.4, 0.5, 0.2, 1.0];
            case VoxelType.DIRT:
                return [0.5, 0.3, 0.1, 1.0];
            case VoxelType.STONE:
                return [0.5, 0.5, 0.5, 1.0];
            case VoxelType.BEDROCK:
                return [0.2, 0.2, 0.2, 1.0];
            case VoxelType.WATER:
                return [0.0, 0.3, 0.8, 0.7];
            default:
                return [1.0, 0.0, 1.0, 1.0]; // Magenta for unknown types
        }
    }

    function getTextureUVs(voxelType, face) {
        // Get texture coordinates from the texture data
        if (!textureData[voxelType]) {
            return [0, 0, 1, 0, 1, 1, 0, 1]; // Default UVs
        }

        let mapping = textureData[voxelType][face];
        if (!mapping) {
            mapping = textureData[voxelType].all;
        }

        if (!mapping) {
            return [0, 0, 1, 0, 1, 1, 0, 1]; // Default UVs
        }

        const tileSize = 16;
        const atlasSize = 256;

        const u0 = mapping.tileX * tileSize / atlasSize;
        const v0 = mapping.tileY * tileSize / atlasSize;
        const u1 = (mapping.tileX + 1) * tileSize / atlasSize;
        const v1 = (mapping.tileY + 1) * tileSize / atlasSize;

        return [u0, v0, u1, v0, u1, v1, u0, v1];
    }

    // For each of the 3 axis directions
    for (let dim = 0; dim < 3; dim++) {
        // Setup axes based on current dimension
        const u = (dim + 1) % 3;
        const v = (dim + 2) % 3;
        const w = dim;

        // Direction vectors for u, v, w
        const uDir = [0, 0, 0];
        const vDir = [0, 0, 0];
        const wDir = [0, 0, 0];

        uDir[u] = 1;
        vDir[v] = 1;
        wDir[w] = 1;

        // Face names and normals based on dimension and direction
        const posDirection = ['right', 'top', 'front']; // +X, +Y, +Z
        const negDirection = ['left', 'bottom', 'back']; // -X, -Y, -Z
        const posNormals = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; // +X, +Y, +Z
        const negNormals = [[-1, 0, 0], [0, -1, 0], [0, 0, -1]]; // -X, -Y, -Z

        // Iterate through each slice of the dimension
        for (let wValue = 0; wValue < CHUNK_SIZE; wValue++) {
            // Two masks for each direction (positive and negative)
            const maskPos = Array(CHUNK_SIZE).fill().map(() =>
                Array(CHUNK_SIZE).fill({ voxelType: 0, transparent: true, visible: false })
            );

            const maskNeg = Array(CHUNK_SIZE).fill().map(() =>
                Array(CHUNK_SIZE).fill({ voxelType: 0, transparent: true, visible: false })
            );

            // Fill both masks for this slice
            for (let vValue = 0; vValue < CHUNK_SIZE; vValue++) {
                for (let uValue = 0; uValue < CHUNK_SIZE; uValue++) {
                    // Set coordinates based on current dimension
                    const x1 = (dim === 0) ? wValue : ((dim === 1) ? uValue : uValue);
                    const y1 = (dim === 0) ? uValue : ((dim === 1) ? wValue : vValue);
                    const z1 = (dim === 0) ? vValue : ((dim === 1) ? vValue : wValue);

                    // Get current voxel
                    const voxel = chunk.getVoxel(x1, y1, z1);
                    const isTransparent1 = isTransparent(voxel);

                    // Get adjacent voxel in positive direction
                    let x2 = x1 + wDir[0];
                    let y2 = y1 + wDir[1];
                    let z2 = z1 + wDir[2];

                    const voxelPos = chunk.getVoxel(x2, y2, z2);
                    const isTransparent2 = isTransparent(voxelPos);

                    // Determine if faces should be created
                    // For positive direction: current solid, next transparent
                    if (voxel !== 0 && (voxelPos === 0 || (isTransparent2 && !isTransparent1))) {
                        maskPos[vValue][uValue] = {
                            voxelType: voxel,
                            transparent: isTransparent1,
                            visible: true
                        };
                    }

                    // For negative direction: current transparent, next solid
                    if (voxelPos !== 0 && (voxel === 0 || (!isTransparent2 && isTransparent1))) {
                        maskNeg[vValue][uValue] = {
                            voxelType: voxelPos,
                            transparent: isTransparent2,
                            visible: true
                        };
                    }
                }
            }

            // Perform greedy meshing on the masks
            // Positive direction mask
            indexOffset = greedyMeshDirection(
                maskPos, dim, wValue, wDir, uDir, vDir, posDirection[dim],
                posNormals[dim], positions, normals, colors, indices, uvs, indexOffset
            );

            // Negative direction mask
            indexOffset = greedyMeshDirection(
                maskNeg, dim, wValue, wDir, uDir, vDir, negDirection[dim],
                negNormals[dim], positions, normals, colors, indices, uvs, indexOffset
            );
        }
    }

    // Helper function to perform greedy meshing on a mask
    function greedyMeshDirection(mask, dim, wValue, wDir, uDir, vDir, faceName, normal,
        positions, normals, colors, indices, uvs, indexOffset) {
        const size = CHUNK_SIZE;

        // Create a visited mask
        const visited = Array(size).fill().map(() => Array(size).fill(false));

        // For each position in the slice
        for (let vStart = 0; vStart < size; vStart++) {
            for (let uStart = 0; uStart < size; uStart++) {
                // Skip if already visited or not visible
                if (visited[vStart][uStart] || !mask[vStart][uStart].visible) {
                    continue;
                }

                // Get voxel type at this position
                const voxelType = mask[vStart][uStart].voxelType;
                const isTransparentVoxel = mask[vStart][uStart].transparent;

                // Find maximum width (u direction)
                let uEnd = uStart;
                while (uEnd + 1 < size &&
                    !visited[vStart][uEnd + 1] &&
                    mask[vStart][uEnd + 1].visible &&
                    mask[vStart][uEnd + 1].voxelType === voxelType &&
                    mask[vStart][uEnd + 1].transparent === isTransparentVoxel) {
                    uEnd++;
                }

                // Find maximum height (v direction)
                let vEnd = vStart;
                let canExpandV = true;

                while (vEnd + 1 < size && canExpandV) {
                    // Check if the entire row can be used
                    for (let u = uStart; u <= uEnd; u++) {
                        if (visited[vEnd + 1][u] ||
                            !mask[vEnd + 1][u].visible ||
                            mask[vEnd + 1][u].voxelType !== voxelType ||
                            mask[vEnd + 1][u].transparent !== isTransparentVoxel) {
                            canExpandV = false;
                            break;
                        }
                    }

                    if (canExpandV) {
                        vEnd++;
                    }
                }

                // Mark all cells in this quad as visited
                for (let v = vStart; v <= vEnd; v++) {
                    for (let u = uStart; u <= uEnd; u++) {
                        visited[v][u] = true;
                    }
                }

                // Create the quad for this merged face
                const width = uEnd - uStart + 1;
                const height = vEnd - vStart + 1;

                // Calculate corner positions based on dimension
                let x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4;

                // Set the w coordinate
                const w = wValue + (dim === 0 ? wDir[0] : 0) + (dim === 1 ? wDir[1] : 0) + (dim === 2 ? wDir[2] : 0);

                // Determine coordinates based on dimension
                if (dim === 0) { // X dimension
                    // Order: bottom-left, bottom-right, top-right, top-left
                    x1 = x2 = x3 = x4 = w;
                    z1 = vStart;
                    y1 = uStart;
                    z2 = vStart;
                    y2 = uStart + width;
                    z3 = vStart + height;
                    y3 = uStart + width;
                    z4 = vStart + height;
                    y4 = uStart;
                } else if (dim === 1) { // Y dimension
                    y1 = y2 = y3 = y4 = w;
                    x1 = uStart;
                    z1 = vStart;
                    x2 = uStart + width;
                    z2 = vStart;
                    x3 = uStart + width;
                    z3 = vStart + height;
                    x4 = uStart;
                    z4 = vStart + height;
                } else { // Z dimension
                    z1 = z2 = z3 = z4 = w;
                    x1 = uStart;
                    y1 = vStart;
                    x2 = uStart + width;
                    y2 = vStart;
                    x3 = uStart + width;
                    y3 = vStart + height;
                    x4 = uStart;
                    y4 = vStart + height;
                }

                // Add vertices for this quad
                positions.push(
                    x1, y1, z1,
                    x2, y2, z2,
                    x3, y3, z3,
                    x4, y4, z4
                );

                // Add normals
                for (let i = 0; i < 4; i++) {
                    normals.push(normal[0], normal[1], normal[2]);
                }

                // Add colors or texture coordinates
                if (Object.keys(textureData).length > 0) {
                    // Use texture coordinates if texture data is available
                    const faceUVs = getTextureUVs(voxelType, faceName);
                    uvs.push(...faceUVs);
                } else {
                    // Otherwise use colors
                    const color = getColor(voxelType, faceName);

                    // Simple directional shading
                    const shade = 1.0 - 0.2 * Math.abs(dim);
                    const finalColor = [
                        color[0] * shade,
                        color[1] * shade,
                        color[2] * shade,
                        color[3]
                    ];

                    // Add colors
                    for (let i = 0; i < 4; i++) {
                        colors.push(...finalColor);
                    }
                }

                // Add indices (two triangles)
                indices.push(
                    indexOffset, indexOffset + 1, indexOffset + 2,
                    indexOffset, indexOffset + 2, indexOffset + 3
                );

                indexOffset += 4;
            }
        }

        return indexOffset;
    }

    // Convert to typed arrays for efficient transfer
    const vertexBuffer = new Float32Array(positions);
    const normalBuffer = new Float32Array(normals);
    const colorBuffer = new Float32Array(colors);
    const indexBuffer = new Uint16Array(indices);
    const uvBuffer = new Float32Array(uvs);

    return {
        x, y, z,
        vertexCount: indices.length,
        vertexBuffer,
        normalBuffer,
        colorBuffer,
        indexBuffer,
        uvBuffer: uvs.length > 0 ? uvBuffer : null
    };
}

// Create crater function
function createCrater(data) {
    const { centerX, centerY, centerZ, radius, chunks } = data;

    // Process each affected chunk
    const modifiedChunks = {};

    // Iterate through the spherical crater volume
    for (let dx = -radius; dx <= radius; dx++) {
        for (let dy = -radius; dy <= radius; dy++) {
            for (let dz = -radius; dz <= radius; dz++) {
                const distSquared = dx * dx + dy * dy + dz * dz;
                if (distSquared > radius * radius) continue;

                const x = centerX + dx;
                const y = centerY + dy;
                const z = centerZ + dz;

                // Calculate chunk coordinates
                const chunkX = Math.floor(x / CHUNK_SIZE);
                const chunkY = Math.floor(y / CHUNK_SIZE);
                const chunkZ = Math.floor(z / CHUNK_SIZE);
                const chunkKey = ${chunkX},${chunkY},${chunkZ};

                // Get or create chunk data
                if (!modifiedChunks[chunkKey]) {
                    // Find this chunk in the provided chunks
                    const chunkData = chunks.find(c =>
                        c.chunkX === chunkX && c.chunkY === chunkY && c.chunkZ === chunkZ
                    );

                    if (chunkData) {
                        modifiedChunks[chunkKey] = {
                            chunkX,
                            chunkY,
                            chunkZ,
                            voxelData: new Uint8Array(chunkData.voxelData)
                        };
                    } else {
                        // Create new chunk data if not found
                        modifiedChunks[chunkKey] = {
                            chunkX,
                            chunkY,
                            chunkZ,
                            voxelData: new Uint8Array(CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE)
                        };
                    }
                }

                // Set voxel to air (0)
                const localX = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const localY = ((y % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const localZ = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

                const index = (localY * CHUNK_SIZE * CHUNK_SIZE) + (localZ * CHUNK_SIZE) + localX;
                modifiedChunks[chunkKey].voxelData[index] = 0;
            }
        }
    }

    return {
        modifiedChunks: Object.values(modifiedChunks)
    };
}

// Height map generation
function getHeight(x, z) {
    const cacheKey = height_${x}_${z};
    if (noiseCache.has(cacheKey)) {
        return noiseCache.get(cacheKey);
    }

    // Large scale terrain features
    const mountainHeight = smoothNoise(x * 0.01, z * 0.01) * 40;

    // Medium scale rolling hills
    const hillHeight = smoothNoise(x * 0.05, z * 0.05) * 10;

    // Small scale detail
    const detailHeight = smoothNoise(x * 0.2, z * 0.2) * 3;

    // Combine the different scales
    const height = Math.floor(10 + mountainHeight + hillHeight + detailHeight);

    noiseCache.set(cacheKey, height);
    return height;
}

// Cave noise function
function getCaveNoise(x, y, z) {
    const cacheKey = cave_${x}_${y}_${z};
    if (noiseCache.has(cacheKey)) {
        return noiseCache.get(cacheKey);
    }

    // 3D noise for cave generation
    const noise = smoothNoise3D(x * 0.1, y * 0.1, z * 0.1);

    noiseCache.set(cacheKey, noise);
    return noise;
}

// Noise functions
function smoothNoise(x, z) {
    // Get integer coordinates
    const x0 = Math.floor(x);
    const z0 = Math.floor(z);

    // Get fractional part
    const xf = x - x0;
    const zf = z - z0;

    // Get corners
    const n00 = noise2D(x0, z0);
    const n10 = noise2D(x0 + 1, z0);
    const n01 = noise2D(x0, z0 + 1);
    const n11 = noise2D(x0 + 1, z0 + 1);

    // Interpolate
    const nx0 = lerp(n00, n10, xf);
    const nx1 = lerp(n01, n11, xf);
    return lerp(nx0, nx1, zf);
}

function smoothNoise3D(x, y, z) {
    // Simplified 3D noise
    const xy = smoothNoise(x, y) * 0.5 + 0.5;
    const yz = smoothNoise(y, z) * 0.5 + 0.5;
    const xz = smoothNoise(x, z) * 0.5 + 0.5;

    return (xy + yz + xz) / 3;
}

function noise2D(x, z) {
    // Simple hash function with seed
    const n = Math.sin(x * 12.9898 + z * 78.233 + seed) * 43758.5453;
    return n - Math.floor(n);
}

function lerp(a, b, t) {
    // Smooth interpolation
    const t2 = (1 - Math.cos(t * Math.PI)) / 2;
    return a * (1 - t2) + b * t2;
}</content></file><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/js/world-generator.js</path><content>import { CHUNK_SIZE, MAX_HEIGHT } from './constants.js';
import { VoxelType } from './voxel-types.js';
import { Chunk } from './voxel-data.js';

export class WorldGenerator {
    constructor() {
        // Seed for reproducible generation
        this.seed = Math.random() * 10000;
    }

    // Generate terrain for a chunk
    generateChunk(chunkX, chunkY, chunkZ) {
        const chunk = new Chunk();

        // Calculate world position of chunk
        const worldX = chunkX * CHUNK_SIZE;
        const worldY = chunkY * CHUNK_SIZE;
        const worldZ = chunkZ * CHUNK_SIZE;

        // Generate terrain
        for (let x = 0; x < CHUNK_SIZE; x++) {
            for (let z = 0; z < CHUNK_SIZE; z++) {
                // World coordinates
                const wx = worldX + x;
                const wz = worldZ + z;

                // Generate a height value using noise
                const baseHeight = this.getHeight(wx, wz);

                // Fill voxels up to the height
                for (let y = 0; y < CHUNK_SIZE; y++) {
                    const wy = worldY + y;

                    // Determine voxel type based on height
                    let voxelType = VoxelType.AIR;

                    if (wy < baseHeight) {
                        // Below surface
                        if (wy < 1) {
                            voxelType = VoxelType.BEDROCK;
                        } else if (wy < baseHeight - 5) {
                            voxelType = VoxelType.STONE;
                        } else if (wy < baseHeight - 1) {
                            voxelType = VoxelType.DIRT;
                        } else {
                            voxelType = VoxelType.GRASS;
                        }

                        // Cave generation
                        if (voxelType !== VoxelType.BEDROCK && this.getCaveNoise(wx, wy, wz) > 0.7) {
                            voxelType = VoxelType.AIR;
                        }
                    } else if (wy < 8) {
                        // Water
                        voxelType = VoxelType.WATER;
                    }

                    // Set voxel in chunk
                    chunk.setVoxel(x, y, z, voxelType);
                }
            }
        }

        return chunk;
    }

    // Height map generation
    getHeight(x, z) {
        // Large scale terrain features
        const mountainHeight = this.smoothNoise(x * 0.01, z * 0.01) * 40;

        // Medium scale rolling hills
        const hillHeight = this.smoothNoise(x * 0.05, z * 0.05) * 10;

        // Small scale detail
        const detailHeight = this.smoothNoise(x * 0.2, z * 0.2) * 3;

        // Combine the different scales
        return Math.floor(10 + mountainHeight + hillHeight + detailHeight);
    }

    // Cave noise function
    getCaveNoise(x, y, z) {
        // 3D noise for cave generation
        return this.smoothNoise3D(x * 0.1, y * 0.1, z * 0.1);
    }

    // Noise functions
    smoothNoise(x, z) {
        // Get integer coordinates
        const x0 = Math.floor(x);
        const z0 = Math.floor(z);

        // Get fractional part
        const xf = x - x0;
        const zf = z - z0;

        // Get corners
        const n00 = this.noise2D(x0, z0);
        const n10 = this.noise2D(x0 + 1, z0);
        const n01 = this.noise2D(x0, z0 + 1);
        const n11 = this.noise2D(x0 + 1, z0 + 1);

        // Interpolate
        const nx0 = this.lerp(n00, n10, xf);
        const nx1 = this.lerp(n01, n11, xf);
        return this.lerp(nx0, nx1, zf);
    }

    smoothNoise3D(x, y, z) {
        // Simplified 3D noise
        const xy = this.smoothNoise(x, y) * 0.5 + 0.5;
        const yz = this.smoothNoise(y, z) * 0.5 + 0.5;
        const xz = this.smoothNoise(x, z) * 0.5 + 0.5;

        return (xy + yz + xz) / 3;
    }

    noise2D(x, z) {
        // Simple hash function with seed
        const n = Math.sin(x * 12.9898 + z * 78.233 + this.seed) * 43758.5453;
        return n - Math.floor(n);
    }

    lerp(a, b, t) {
        // Smooth interpolation
        const t2 = (1 - Math.cos(t * Math.PI)) / 2;
        return a * (1 - t2) + b * t2;
    }
}</content></file></codebase><codebase><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/old_0/.DS_Store</path><content>   Bud1                                                                     blob   bpli                                                                                                                                                                           j sbwspblob   bplist00]ShowStatusBar[ShowToolbar[ShowTabView_ContainerShowSidebar\WindowBounds[ShowSidebar		_{{499, 560}, {920, 436}}	#/;R_klmno             
                   j svSrnlong                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     @                                              @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   E                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         DSDB                                                                                    @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </content></file><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/old_0/index.html</path><content><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modular Voxel Engine</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        .overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px;
        }
        .stats {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-family: monospace;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <div class="overlay">
        <p>Click to create craters (deform terrain)</p>
        <p>WASD to move, Mouse to look around</p>
        <p>C to move up, X to move down</p>
        <p>SPACE to create crater (where you're looking)</p>
    </div>
    <div class="stats" id="stats">
        <p>FPS: <span id="fps">0</span></p>
        <p>Chunks: <span id="chunks">0</span></p>
        <p>Vertices: <span id="vertices">0</span></p>
        <p>Position: <span id="position">0,0,0</span></p>
    </div>
    
    <!-- Load modules in the correct order -->
    <script type="module" src="js/main.js"></script>
</body>
</html></content></file><codebase><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/old_0/js/chunk-manager.js</path><content>import { CHUNK_SIZE, RENDER_DISTANCE } from './constants.js';
import { debugLog } from './math-utils.js';
import { Chunk } from './voxel-data.js';

export class ChunkManager {
    constructor(worldGenerator, mesher, renderer) {
        this.worldGenerator = worldGenerator;
        this.mesher = mesher;
        this.renderer = renderer;

        this.chunks = new Map();  // Map of loaded chunks
        this.meshes = new Map();  // Map of chunk meshes
        this.dirtyChunks = new Set(); // Chunks that need mesh rebuilding
        this.loadQueue = [];      // Queue for chunks to load
        this.unloadQueue = [];    // Queue for chunks to unload
        this.totalChunks = 0;
    }

    // Create chunk key from coordinates
    getChunkKey(x, y, z) {
        return ${x},${y},${z};
    }

    // Get chunk at coordinates
    getChunk(x, y, z) {
        return this.chunks.get(this.getChunkKey(x, y, z));
    }

    // Check if chunk exists
    hasChunk(x, y, z) {
        return this.chunks.has(this.getChunkKey(x, y, z));
    }

    // Get chunk mesh
    getChunkMesh(x, y, z) {
        return this.meshes.get(this.getChunkKey(x, y, z));
    }

    // Mark chunk as dirty (needs mesh rebuild)
    markChunkDirty(x, y, z) {
        const key = this.getChunkKey(x, y, z);
        if (this.chunks.has(key)) {
            this.dirtyChunks.add(key);
            debugLog(Marked chunk dirty: ${key});
        }

        // Also mark neighboring chunks as dirty if they could be affected
        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dz = -1; dz <= 1; dz++) {
                    if (dx === 0 && dy === 0 && dz === 0) continue;
                    const neighborKey = this.getChunkKey(x + dx, y + dy, z + dz);
                    if (this.chunks.has(neighborKey)) {
                        this.dirtyChunks.add(neighborKey);
                    }
                }
            }
        }
    }

    // Create or get a chunk
    getOrCreateChunk(chunkX, chunkY, chunkZ) {
        const key = this.getChunkKey(chunkX, chunkY, chunkZ);

        if (this.chunks.has(key)) {
            return this.chunks.get(key);
        }

        // Generate a new chunk
        debugLog(Creating new chunk at ${chunkX}, ${chunkY}, ${chunkZ});
        const chunk = this.worldGenerator.generateChunk(chunkX, chunkY, chunkZ);

        this.chunks.set(key, chunk);
        this.dirtyChunks.add(key);
        this.totalChunks++;

        return chunk;
    }

    // Update chunks based on player position
    updateChunks(playerX, playerY, playerZ) {
        // Convert player position to chunk coordinates
        const centerChunkX = Math.floor(playerX / CHUNK_SIZE);
        const centerChunkY = Math.floor(playerY / CHUNK_SIZE);
        const centerChunkZ = Math.floor(playerZ / CHUNK_SIZE);

        // Add chunks that should be loaded to queue
        for (let x = centerChunkX - RENDER_DISTANCE; x <= centerChunkX + RENDER_DISTANCE; x++) {
            for (let y = 0; y <= centerChunkY + RENDER_DISTANCE; y++) {
                for (let z = centerChunkZ - RENDER_DISTANCE; z <= centerChunkZ + RENDER_DISTANCE; z++) {
                    // Skip chunks that are too far away (use spherical distance)
                    const dx = x - centerChunkX;
                    const dy = y - centerChunkY;
                    const dz = z - centerChunkZ;
                    const distSquared = dx * dx + dy * dy + dz * dz;

                    if (distSquared <= RENDER_DISTANCE * RENDER_DISTANCE && !this.hasChunk(x, y, z)) {
                        // Prioritize chunks closer to player
                        this.loadQueue.push({ coords: [x, y, z], dist: distSquared });
                    }
                }
            }
        }

        // Sort load queue by distance for priority loading
        this.loadQueue.sort((a, b) => a.dist - b.dist);

        // Add chunks that should be unloaded to queue
        for (const [key, chunk] of this.chunks.entries()) {
            const [x, y, z] = key.split(',').map(Number);
            const dx = x - centerChunkX;
            const dy = y - centerChunkY;
            const dz = z - centerChunkZ;
            const distSquared = dx * dx + dy * dy + dz * dz;

            if (distSquared > RENDER_DISTANCE * RENDER_DISTANCE * 1.5) { // 1.5x radius for unloading
                this.unloadQueue.push([x, y, z]);
            }
        }

        // Process load queue (limited per frame)
        const loadLimit = 2;
        let loaded = 0;

        while (this.loadQueue.length > 0 && loaded < loadLimit) {
            const { coords } = this.loadQueue.shift();
            const [x, y, z] = coords;
            if (!this.hasChunk(x, y, z)) {
                this.getOrCreateChunk(x, y, z);
                loaded++;
            }
        }

        // Process unload queue
        const unloadLimit = 1;
        let unloaded = 0;

        while (this.unloadQueue.length > 0 && unloaded < unloadLimit) {
            const [x, y, z] = this.unloadQueue.shift();
            this.unloadChunk(x, y, z);
            unloaded++;
        }

        // Update stats display
        document.getElementById('chunks').textContent = this.totalChunks;
        document.getElementById('position').textContent = ${Math.floor(playerX)},${Math.floor(playerY)},${Math.floor(playerZ)};
    }

    // Unload a chunk
    unloadChunk(x, y, z) {
        const key = this.getChunkKey(x, y, z);

        if (this.chunks.has(key)) {
            this.chunks.delete(key);

            // Delete mesh if it exists
            if (this.meshes.has(key)) {
                const mesh = this.meshes.get(key);
                this.renderer.deleteMesh(mesh);
                this.meshes.delete(key);
            }

            this.dirtyChunks.delete(key);
            this.totalChunks--;
            debugLog(Unloaded chunk at ${x}, ${y}, ${z});
        }
    }

    // Build/rebuild meshes for dirty chunks
    buildChunkMeshes() {
        // Limit rebuilds per frame
        const rebuildLimit = 2;
        let rebuilt = 0;

        for (const key of this.dirtyChunks) {
            if (rebuilt >= rebuildLimit) break;

            const [x, y, z] = key.split(',').map(Number);
            const chunk = this.getChunk(x, y, z);

            if (chunk) {
                // Generate mesh
                const mesh = this.mesher.generateMesh(chunk, x, y, z,
                    (cx, cy, cz) => this.getChunk(cx, cy, cz));

                // Skip if no vertices (empty chunk)
                if (mesh.positions.length === 0) {
                    this.dirtyChunks.delete(key);
                    // Delete existing mesh if it exists
                    if (this.meshes.has(key)) {
                        this.renderer.deleteMesh(this.meshes.get(key));
                        this.meshes.delete(key);
                    }
                    continue;
                }

                // Create WebGL mesh
                const worldOffset = [x * CHUNK_SIZE, y * CHUNK_SIZE, z * CHUNK_SIZE];
                const glMesh = this.renderer.createMesh(mesh, worldOffset);

                // Delete old mesh if it exists
                if (this.meshes.has(key)) {
                    this.renderer.deleteMesh(this.meshes.get(key));
                }

                // Store mesh
                this.meshes.set(key, glMesh);
                this.dirtyChunks.delete(key);
                rebuilt++;

                debugLog(Built mesh for chunk ${key}: ${mesh.positions.length / 3} vertices);
            }
        }

        // Update total vertex count
        let totalVertices = 0;
        for (const mesh of this.meshes.values()) {
            totalVertices += mesh.vertexCount;
        }
        document.getElementById('vertices').textContent = totalVertices;
    }

    // Get voxel at world coordinates
    getVoxel(worldX, worldY, worldZ) {
        // Convert to chunk coordinates
        const chunkX = Math.floor(worldX / CHUNK_SIZE);
        const chunkY = Math.floor(worldY / CHUNK_SIZE);
        const chunkZ = Math.floor(worldZ / CHUNK_SIZE);

        // Get chunk
        const chunk = this.getChunk(chunkX, chunkY, chunkZ);
        if (!chunk) {
            return 0; // Assume air if chunk not loaded
        }

        // Convert to local coordinates
        const localX = ((worldX % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
        const localY = ((worldY % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
        const localZ = ((worldZ % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

        return chunk.getVoxel(localX, localY, localZ);
    }

    // Set voxel at world coordinates
    setVoxel(worldX, worldY, worldZ, voxelType) {
        // Convert to chunk coordinates
        const chunkX = Math.floor(worldX / CHUNK_SIZE);
        const chunkY = Math.floor(worldY / CHUNK_SIZE);
        const chunkZ = Math.floor(worldZ / CHUNK_SIZE);

        // Convert to local coordinates within chunk
        const localX = ((worldX % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
        const localY = ((worldY % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
        const localZ = ((worldZ % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

        debugLog(Setting voxel at ${worldX},${worldY},${worldZ} (chunk ${chunkX},${chunkY},${chunkZ}, local ${localX},${localY},${localZ}));

        // Get or create chunk
        let chunk = this.getChunk(chunkX, chunkY, chunkZ);
        if (!chunk) {
            chunk = this.getOrCreateChunk(chunkX, chunkY, chunkZ);
        }

        // Update voxel in chunk
        chunk.setVoxel(localX, localY, localZ, voxelType);

        // Mark chunk as dirty
        this.markChunkDirty(chunkX, chunkY, chunkZ);

        // Mark neighboring chunks as dirty if this voxel is on a boundary
        if (localX === 0) this.markChunkDirty(chunkX - 1, chunkY, chunkZ);
        if (localX === CHUNK_SIZE - 1) this.markChunkDirty(chunkX + 1, chunkY, chunkZ);
        if (localY === 0) this.markChunkDirty(chunkX, chunkY - 1, chunkZ);
        if (localY === CHUNK_SIZE - 1) this.markChunkDirty(chunkX, chunkY + 1, chunkZ);
        if (localZ === 0) this.markChunkDirty(chunkX, chunkY, chunkZ - 1);
        if (localZ === CHUNK_SIZE - 1) this.markChunkDirty(chunkX, chunkY, chunkZ + 1);
    }

    // Create a crater at world coordinates
    createCrater(worldX, worldY, worldZ, radius) {
        debugLog(Creating crater at ${worldX}, ${worldY}, ${worldZ} with radius ${radius});

        const radiusSquared = radius * radius;

        for (let dx = -radius; dx <= radius; dx++) {
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dz = -radius; dz <= radius; dz++) {
                    const distSquared = dx * dx + dy * dy + dz * dz;
                    if (distSquared <= radiusSquared) {
                        this.setVoxel(Math.floor(worldX + dx), Math.floor(worldY + dy), Math.floor(worldZ + dz), 0);
                    }
                }
            }
        }
    }

    // Perform raycast against voxels
    raycast(origin, direction, maxDistance = 100) {
        debugLog(Raycasting from ${origin} in direction ${direction});

        const stepSize = 0.1;
        const maxSteps = maxDistance / stepSize;

        let currentPos = [...origin];

        for (let i = 0; i < maxSteps; i++) {
            const x = Math.floor(currentPos[0]);
            const y = Math.floor(currentPos[1]);
            const z = Math.floor(currentPos[2]);

            // Check if we've hit a voxel
            const voxel = this.getVoxel(x, y, z);
            if (voxel !== 0) {
                debugLog(Raycast hit at ${x}, ${y}, ${z}, voxel type: ${voxel});
                return {
                    position: [x, y, z],
                    voxelType: voxel,
                    distance: i * stepSize
                };
            }

            // Move along the ray
            currentPos[0] += direction[0] * stepSize;
            currentPos[1] += direction[1] * stepSize;
            currentPos[2] += direction[2] * stepSize;
        }

        debugLog(Raycast missed (exceeded maxDistance));
        return null; // No hit
    }

    // Render all chunks
    render(projectionMatrix, viewMatrix) {
        this.renderer.renderChunks(this.meshes.values(), projectionMatrix, viewMatrix);
    }
}</content></file><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/old_0/js/constants.js</path><content>export const CHUNK_SIZE = 16;
export const RENDER_DISTANCE = 5;
export const MAX_HEIGHT = 64;
export const DEBUG = true;</content></file><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/old_0/js/controls.js</path><content>import { normalizeVector, debugLog } from './math-utils.js';
import { VoxelType } from './voxel-types.js';

export class Controls {
    constructor(canvas, camera, chunkManager) {
        this.canvas = canvas;
        this.camera = camera;
        this.chunkManager = chunkManager;

        // Movement state
        this.moveForward = false;
        this.moveBackward = false;
        this.moveLeft = false;
        this.moveRight = false;
        this.moveUp = false;
        this.moveDown = false;

        // Mouse state
        this.isPointerLocked = false;

        this.setupInputHandlers();
    }

    setupInputHandlers() {
        // Mouse movement for camera rotation
        document.addEventListener('mousemove', (e) => {
            if (this.isPointerLocked) {
                const sensitivity = 0.002;
                this.camera.rotation[0] -= e.movementX * sensitivity;
                this.camera.rotation[1] -= e.movementY * sensitivity;

                // Clamp vertical rotation to prevent flipping
                this.camera.rotation[1] = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, this.camera.rotation[1]));
            }
        });

        // Handle pointer lock
        document.addEventListener('pointerlockchange', () => {
            this.isPointerLocked = document.pointerLockElement === this.canvas;
            debugLog(Pointer lock: ${this.isPointerLocked});
        });

        // Click to lock pointer
        this.canvas.addEventListener('click', () => {
            if (!this.isPointerLocked) {
                this.canvas.requestPointerLock();
            }
        });

        // Mouse down to create crater
        this.canvas.addEventListener('mousedown', (e) => {
            // Only proceed if pointer is locked (we have control)
            if (this.isPointerLocked) {
                this.createCraterAtLookDirection(3);
            }
        });

        // Keyboard controls
        window.addEventListener('keydown', (e) => {
            switch (e.key.toLowerCase()) {
                case 'w': this.moveForward = true; break;
                case 's': this.moveBackward = true; break;
                case 'a': this.moveLeft = true; break;
                case 'd': this.moveRight = true; break;
                case 'c': this.moveUp = true; break;
                case 'x': this.moveDown = true; break;
                case ' ': // Space to create crater at look direction
                    this.createCraterAtLookDirection(5);
                    break;
            }
        });

        window.addEventListener('keyup', (e) => {
            switch (e.key.toLowerCase()) {
                case 'w': this.moveForward = false; break;
                case 's': this.moveBackward = false; break;
                case 'a': this.moveLeft = false; break;
                case 'd': this.moveRight = false; break;
                case 'c': this.moveUp = false; break;
                case 'x': this.moveDown = false; break;
            }
        });
    }

    createCraterAtLookDirection(radius) {
        // Calculate ray from camera
        const ray = {
            origin: [...this.camera.position],
            direction: this.getLookDirection()
        };

        // Raycast to find hit point
        const hit = this.chunkManager.raycast(ray.origin, ray.direction, 50);
        if (hit) {
            this.chunkManager.createCrater(hit.position[0], hit.position[1], hit.position[2], radius);
        }
    }

    getLookDirection() {
        const direction = [
            Math.sin(this.camera.rotation[0]) * Math.cos(this.camera.rotation[1]),
            Math.sin(this.camera.rotation[1]),
            Math.cos(this.camera.rotation[0]) * Math.cos(this.camera.rotation[1])
        ];

        return normalizeVector(direction);
    }

    update(deltaTime) {
        // Get forward and right vectors
        const forward = [
            Math.sin(this.camera.rotation[0]) * Math.cos(this.camera.rotation[1]),
            0, // No vertical component for forward movement
            Math.cos(this.camera.rotation[0]) * Math.cos(this.camera.rotation[1])
        ];
        normalizeVector(forward);

        const right = [
            Math.sin(this.camera.rotation[0] + Math.PI / 2),
            0,
            Math.cos(this.camera.rotation[0] + Math.PI / 2)
        ];

        // Apply movement
        const moveSpeed = 10 * deltaTime; // Units per second

        if (this.moveForward) {
            this.camera.position[0] += forward[0] * moveSpeed;
            this.camera.position[2] += forward[2] * moveSpeed;
        }
        if (this.moveBackward) {
            this.camera.position[0] -= forward[0] * moveSpeed;
            this.camera.position[2] -= forward[2] * moveSpeed;
        }
        if (this.moveRight) {
            this.camera.position[0] += right[0] * moveSpeed;
            this.camera.position[2] += right[2] * moveSpeed;
        }
        if (this.moveLeft) {
            this.camera.position[0] -= right[0] * moveSpeed;
            this.camera.position[2] -= right[2] * moveSpeed;
        }
        if (this.moveUp) {
            this.camera.position[1] += moveSpeed;
        }
        if (this.moveDown) {
            this.camera.position[1] -= moveSpeed;
        }
    }
}</content></file><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/old_0/js/main.js</path><content>import { CHUNK_SIZE, RENDER_DISTANCE } from './constants.js';
import { mat4 } from './math-utils.js';
import { VoxelTypeManager } from './voxel-types.js';
import { WorldGenerator } from './world-generator.js';
import { Mesher } from './mesher.js';
import { ChunkManager } from './chunk-manager.js';
import { Renderer } from './renderer.js';
import { Controls } from './controls.js';

// Main class that ties everything together
class VoxelEngine {
    constructor() {
        // Camera state
        this.camera = {
            position: [0, 20, 0],
            rotation: [0, 0] // [yaw, pitch]
        };

        // Performance tracking
        this.lastFrameTime = 0;
        this.frameCount = 0;
        this.fps = 0;

        // Initialize components
        this.canvas = document.getElementById('glCanvas');
        this.renderer = new Renderer(this.canvas);
        this.voxelTypes = new VoxelTypeManager();
        this.worldGenerator = new WorldGenerator();
        this.mesher = new Mesher(this.voxelTypes);
        this.chunkManager = new ChunkManager(this.worldGenerator, this.mesher, this.renderer);
        this.controls = new Controls(this.canvas, this.camera, this.chunkManager);

        // Start the game loop
        requestAnimationFrame(this.render.bind(this));
    }

    render(now) {
        // Calculate delta time (in seconds)
        const deltaTime = (now - (this.lastTime || now)) / 1000;
        this.lastTime = now;

        // Calculate FPS
        this.frameCount++;
        if (now - this.lastFrameTime >= 1000) {
            this.fps = Math.round((this.frameCount * 1000) / (now - this.lastFrameTime));
            document.getElementById('fps').textContent = this.fps;
            this.frameCount = 0;
            this.lastFrameTime = now;
        }

        // Update controls
        this.controls.update(deltaTime);

        // Update chunks based on camera position
        this.chunkManager.updateChunks(
            this.camera.position[0],
            this.camera.position[1],
            this.camera.position[2]
        );

        // Build/update chunk meshes
        this.chunkManager.buildChunkMeshes();

        // Resize canvas
        this.renderer.resizeCanvasToDisplaySize();

        // Clear the screen
        this.renderer.clear();

        // Set up camera and projection matrices
        const projectionMatrix = mat4.create();
        const fieldOfView = 70 * Math.PI / 180; // Wider FOV for better visibility
        const aspect = this.canvas.clientWidth / this.canvas.clientHeight;
        const zNear = 0.1;
        const zFar = CHUNK_SIZE * (RENDER_DISTANCE + 1) * 1.5;

        mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);

        // Create camera view matrix
        const viewMatrix = mat4.create();
        const forward = [
            Math.sin(this.camera.rotation[0]) * Math.cos(this.camera.rotation[1]),
            Math.sin(this.camera.rotation[1]),
            Math.cos(this.camera.rotation[0]) * Math.cos(this.camera.rotation[1])
        ];

        const target = [
            this.camera.position[0] + forward[0],
            this.camera.position[1] + forward[1],
            this.camera.position[2] + forward[2]
        ];

        const up = [0, 1, 0];
        mat4.lookAt(viewMatrix, this.camera.position, target, up);

        // Render all chunks
        this.chunkManager.render(projectionMatrix, viewMatrix);

        // Request next frame
        requestAnimationFrame(this.render.bind(this));
    }
}

// Initialize the engine when the page loads
window.onload = () => {
    window.voxelEngine = new VoxelEngine();
};</content></file><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/old_0/js/math-utils.js</path><content>import { CHUNK_SIZE, DEBUG } from './constants.js';

export const mat4 = {
    create() {
        return new Float32Array([
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        ]);
    },

    perspective(out, fovy, aspect, near, far) {
        const f = 1.0 / Math.tan(fovy / 2);
        out[0] = f / aspect;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = f;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = (far + near) / (near - far);
        out[11] = -1;
        out[12] = 0;
        out[13] = 0;
        out[14] = (2 * far * near) / (near - far);
        out[15] = 0;
        return out;
    },

    lookAt(out, eye, center, up) {
        let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;

        // z = normalized(eye - center)
        z0 = eye[0] - center[0];
        z1 = eye[1] - center[1];
        z2 = eye[2] - center[2];

        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
        z0 *= len;
        z1 *= len;
        z2 *= len;

        // x = normalized(cross(up, z))
        x0 = up[1] * z2 - up[2] * z1;
        x1 = up[2] * z0 - up[0] * z2;
        x2 = up[0] * z1 - up[1] * z0;

        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
        if (!len) {
            x0 = 0;
            x1 = 0;
            x2 = 0;
        } else {
            len = 1 / len;
            x0 *= len;
            x1 *= len;
            x2 *= len;
        }

        // y = cross(z, x)
        y0 = z1 * x2 - z2 * x1;
        y1 = z2 * x0 - z0 * x2;
        y2 = z0 * x1 - z1 * x0;

        out[0] = x0;
        out[1] = y0;
        out[2] = z0;
        out[3] = 0;
        out[4] = x1;
        out[5] = y1;
        out[6] = z1;
        out[7] = 0;
        out[8] = x2;
        out[9] = y2;
        out[10] = z2;
        out[11] = 0;
        out[12] = -(x0 * eye[0] + x1 * eye[1] + x2 * eye[2]);
        out[13] = -(y0 * eye[0] + y1 * eye[1] + y2 * eye[2]);
        out[14] = -(z0 * eye[0] + z1 * eye[1] + z2 * eye[2]);
        out[15] = 1;

        return out;
    },

    invert(out, a) {
        const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
        const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
        const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
        const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

        const b00 = a00 * a11 - a01 * a10;
        const b01 = a00 * a12 - a02 * a10;
        const b02 = a00 * a13 - a03 * a10;
        const b03 = a01 * a12 - a02 * a11;
        const b04 = a01 * a13 - a03 * a11;
        const b05 = a02 * a13 - a03 * a12;
        const b06 = a20 * a31 - a21 * a30;
        const b07 = a20 * a32 - a22 * a30;
        const b08 = a20 * a33 - a23 * a30;
        const b09 = a21 * a32 - a22 * a31;
        const b10 = a21 * a33 - a23 * a31;
        const b11 = a22 * a33 - a23 * a32;

        // Calculate the determinant
        let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

        if (!det) {
            return null;
        }
        det = 1.0 / det;

        out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
        out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
        out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
        out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
        out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
        out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
        out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
        out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
        out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
        out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
        out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
        out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
        out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
        out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
        out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
        out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

        return out;
    },

    translate(out, a, v) {
        const x = v[0], y = v[1], z = v[2];

        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];

        return out;
    },

    multiply(out, a, b) {
        const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
        const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
        const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
        const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

        let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
        out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
        out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
        out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
        out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        return out;
    },

    transpose(out, a) {
        if (out === a) {
            const a01 = a[1], a02 = a[2], a03 = a[3];
            const a12 = a[6], a13 = a[7];
            const a23 = a[11];

            out[1] = a[4];
            out[2] = a[8];
            out[3] = a[12];
            out[4] = a01;
            out[6] = a[9];
            out[7] = a[13];
            out[8] = a02;
            out[9] = a12;
            out[11] = a[14];
            out[12] = a03;
            out[13] = a13;
            out[14] = a23;
        } else {
            out[0] = a[0];
            out[1] = a[4];
            out[2] = a[8];
            out[3] = a[12];
            out[4] = a[1];
            out[5] = a[5];
            out[6] = a[9];
            out[7] = a[13];
            out[8] = a[2];
            out[9] = a[6];
            out[10] = a[10];
            out[11] = a[14];
            out[12] = a[3];
            out[13] = a[7];
            out[14] = a[11];
            out[15] = a[15];
        }

        return out;
    }
};

export function normalizeVector(v) {
    const length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
    if (length === 0) return v;

    v[0] /= length;
    v[1] /= length;
    v[2] /= length;
    return v;
}

export function debugLog(message) {
    if (DEBUG) {
        console.log(message);
    }
}</content></file><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/old_0/js/mesher.js</path><content>import { CHUNK_SIZE } from './constants.js';
import { debugLog } from './math-utils.js';
import { VoxelType, VoxelTypeManager } from './voxel-types.js';

export class Mesher {
    constructor(voxelTypeManager) {
        this.voxelTypes = voxelTypeManager;
    }

    // Generate mesh from chunk data
    generateMesh(chunk, chunkX, chunkY, chunkZ, getNeighborChunk) {
        const positions = [];
        const normals = [];
        const colors = [];
        const indices = [];
        let indexOffset = 0;

        // Skip empty chunks
        if (chunk.isEmpty()) {
            return { positions, normals, colors, indices };
        }

        // Directions for checking adjacent voxels
        const directions = [
            [1, 0, 0], [-1, 0, 0], [0, 1, 0], [0, -1, 0], [0, 0, 1], [0, 0, -1]
        ];

        // Face names for color selection
        const faceNames = ['right', 'left', 'top', 'bottom', 'front', 'back'];

        // Corresponding face normals
        const faceNormals = [
            [1, 0, 0], [-1, 0, 0], [0, 1, 0], [0, -1, 0], [0, 0, 1], [0, 0, -1]
        ];

        // Vertex offsets for each face (CCW winding)
        const faceVertices = [
            // Right face (+X)
            [[1, 0, 0], [1, 0, 1], [1, 1, 1], [1, 1, 0]],
            // Left face (-X)
            [[0, 0, 0], [0, 1, 0], [0, 1, 1], [0, 0, 1]],
            // Top face (+Y)
            [[0, 1, 0], [1, 1, 0], [1, 1, 1], [0, 1, 1]],
            // Bottom face (-Y)
            [[0, 0, 0], [0, 0, 1], [1, 0, 1], [1, 0, 0]],
            // Front face (+Z)
            [[0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 0, 1]],
            // Back face (-Z)
            [[0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0]]
        ];

        // Loop through all voxels in this chunk
        for (let y = 0; y < CHUNK_SIZE; y++) {
            for (let z = 0; z < CHUNK_SIZE; z++) {
                for (let x = 0; x < CHUNK_SIZE; x++) {
                    const voxelType = chunk.getVoxel(x, y, z);

                    // Skip if air
                    if (voxelType === VoxelType.AIR) continue;

                    // Check all six faces
                    for (let faceDir = 0; faceDir < 6; faceDir++) {
                        const dir = directions[faceDir];
                        const nx = x + dir[0];
                        const ny = y + dir[1];
                        const nz = z + dir[2];

                        // Get neighbor voxel type
                        let neighborVoxel;

                        // Check if neighbor is in another chunk
                        if (nx < 0 || nx >= CHUNK_SIZE || ny < 0 || ny >= CHUNK_SIZE || nz < 0 || nz >= CHUNK_SIZE) {
                            // Calculate neighbor chunk coordinates
                            let neighborChunkX = chunkX;
                            let neighborChunkY = chunkY;
                            let neighborChunkZ = chunkZ;
                            let neighborLocalX = nx;
                            let neighborLocalY = ny;
                            let neighborLocalZ = nz;

                            if (nx < 0) {
                                neighborChunkX--;
                                neighborLocalX += CHUNK_SIZE;
                            } else if (nx >= CHUNK_SIZE) {
                                neighborChunkX++;
                                neighborLocalX -= CHUNK_SIZE;
                            }

                            if (ny < 0) {
                                neighborChunkY--;
                                neighborLocalY += CHUNK_SIZE;
                            } else if (ny >= CHUNK_SIZE) {
                                neighborChunkY++;
                                neighborLocalY -= CHUNK_SIZE;
                            }

                            if (nz < 0) {
                                neighborChunkZ--;
                                neighborLocalZ += CHUNK_SIZE;
                            } else if (nz >= CHUNK_SIZE) {
                                neighborChunkZ++;
                                neighborLocalZ -= CHUNK_SIZE;
                            }

                            // Get neighbor chunk
                            const neighborChunk = getNeighborChunk(neighborChunkX, neighborChunkY, neighborChunkZ);
                            if (neighborChunk) {
                                neighborVoxel = neighborChunk.getVoxel(neighborLocalX, neighborLocalY, neighborLocalZ);
                            } else {
                                // Chunk not loaded, so assume air
                                neighborVoxel = VoxelType.AIR;
                            }
                        } else {
                            // Get voxel from this chunk
                            neighborVoxel = chunk.getVoxel(nx, ny, nz);
                        }

                        // Add face if neighbor is air or transparent
                        if (neighborVoxel === VoxelType.AIR ||
                            (this.voxelTypes.isTransparent(neighborVoxel) &&
                                !this.voxelTypes.isTransparent(voxelType))) {

                            // Get vertices for this face
                            const faceVerts = faceVertices[faceDir];
                            const normal = faceNormals[faceDir];
                            const faceName = faceNames[faceDir];

                            // Get color from voxel type manager
                            const color = this.voxelTypes.getColor(voxelType, faceName);

                            // Simple directional shading
                            const shade = 1.0 - 0.2 * Math.abs(faceDir % 3);
                            const finalColor = [
                                color[0] * shade,
                                color[1] * shade,
                                color[2] * shade,
                                color[3]
                            ];

                            // Add vertices for this face
                            for (let i = 0; i < 4; i++) {
                                const vert = faceVerts[i];
                                positions.push(x + vert[0], y + vert[1], z + vert[2]);
                                normals.push(normal[0], normal[1], normal[2]);
                                colors.push(...finalColor);
                            }

                            // Add two triangles (CCW winding order)
                            indices.push(
                                indexOffset, indexOffset + 1, indexOffset + 2,
                                indexOffset, indexOffset + 2, indexOffset + 3
                            );

                            indexOffset += 4;
                        }
                    }
                }
            }
        }

        return {
            positions,
            normals,
            colors,
            indices
        };
    }
}</content></file><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/old_0/js/renderer.js</path><content>import { DEBUG } from './constants.js';
import { mat4, debugLog } from './math-utils.js';

export class Renderer {
    constructor(canvas) {
        this.canvas = canvas;
        this.gl = canvas.getContext('webgl');

        if (!this.gl) {
            throw new Error('WebGL not supported');
        }

        this.programInfo = null;
        this.initWebGL();
    }

    // Initialize WebGL
    initWebGL() {
        // Create shaders
        const vsSource = 
            attribute vec4 aVertexPosition;
            attribute vec3 aVertexNormal;
            attribute vec4 aVertexColor;

            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform mat4 uNormalMatrix;

            varying highp vec3 vNormal;
            varying highp vec4 vColor;

            void main(void) {
                gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
                vNormal = (uNormalMatrix * vec4(aVertexNormal, 0.0)).xyz;
                vColor = aVertexColor;
            }
        ;

        const fsSource = 
            precision highp float;
            
            varying highp vec3 vNormal;
            varying highp vec4 vColor;
            
            uniform vec3 uLightDirection;
            
            void main(void) {
                // Calculate lighting
                vec3 normal = normalize(vNormal);
                vec3 lightDir = normalize(uLightDirection);
                float diffuse = max(dot(normal, lightDir), 0.0);
                
                // Add ambient light
                float ambient = 0.3;
                float lighting = diffuse + ambient;
                
                // Apply lighting to color (preserve alpha)
                vec4 litColor = vec4(vColor.rgb * lighting, vColor.a);
                
                gl_FragColor = litColor;
            }
        ;

        // Initialize the shader program
        const shaderProgram = this.initShaderProgram(vsSource, fsSource);

        // Store program info
        this.programInfo = {
            program: shaderProgram,
            attribLocations: {
                vertexPosition: this.gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                vertexNormal: this.gl.getAttribLocation(shaderProgram, 'aVertexNormal'),
                vertexColor: this.gl.getAttribLocation(shaderProgram, 'aVertexColor'),
            },
            uniformLocations: {
                projectionMatrix: this.gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                modelViewMatrix: this.gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
                normalMatrix: this.gl.getUniformLocation(shaderProgram, 'uNormalMatrix'),
                lightDirection: this.gl.getUniformLocation(shaderProgram, 'uLightDirection'),
            },
        };

        debugLog('WebGL initialized');
    }

    // Create a shader program
    initShaderProgram(vsSource, fsSource) {
        const vertexShader = this.loadShader(this.gl.VERTEX_SHADER, vsSource);
        const fragmentShader = this.loadShader(this.gl.FRAGMENT_SHADER, fsSource);

        if (!vertexShader || !fragmentShader) {
            return null;
        }

        const shaderProgram = this.gl.createProgram();
        this.gl.attachShader(shaderProgram, vertexShader);
        this.gl.attachShader(shaderProgram, fragmentShader);
        this.gl.linkProgram(shaderProgram);

        if (!this.gl.getProgramParameter(shaderProgram, this.gl.LINK_STATUS)) {
            console.error('Unable to initialize shader program: ' + this.gl.getProgramInfoLog(shaderProgram));
            return null;
        }

        return shaderProgram;
    }

    // Compile a shader
    loadShader(type, source) {
        const shader = this.gl.createShader(type);
        this.gl.shaderSource(shader, source);
        this.gl.compileShader(shader);

        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            console.error('Shader compilation error: ' + this.gl.getShaderInfoLog(shader));
            this.gl.deleteShader(shader);
            return null;
        }

        return shader;
    }

    // Create a mesh in WebGL
    createMesh(meshData, worldOffset) {
        const { positions, normals, colors, indices } = meshData;

        // Create buffers
        const positionBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);

        const normalBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, normalBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normals), this.gl.STATIC_DRAW);

        const colorBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, colorBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), this.gl.STATIC_DRAW);

        const indexBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), this.gl.STATIC_DRAW);

        // Return mesh object
        return {
            position: positionBuffer,
            normal: normalBuffer,
            color: colorBuffer,
            indices: indexBuffer,
            vertexCount: indices.length,
            worldOffset
        };
    }

    // Delete a mesh
    deleteMesh(mesh) {
        this.gl.deleteBuffer(mesh.position);
        this.gl.deleteBuffer(mesh.normal);
        this.gl.deleteBuffer(mesh.color);
        this.gl.deleteBuffer(mesh.indices);
    }

    // Resize canvas to match display size
    resizeCanvasToDisplaySize() {
        const displayWidth = this.canvas.clientWidth;
        const displayHeight = this.canvas.clientHeight;

        if (this.canvas.width !== displayWidth || this.canvas.height !== displayHeight) {
            this.canvas.width = displayWidth;
            this.canvas.height = displayHeight;
            this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            return true;
        }
        return false;
    }

    // Clear the screen
    clear() {
        this.gl.clearColor(0.6, 0.8, 1.0, 1.0); // Sky blue
        this.gl.clearDepth(1.0);
        this.gl.enable(this.gl.DEPTH_TEST);
        this.gl.depthFunc(this.gl.LEQUAL);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
    }

    // Render all chunks
    renderChunks(meshes, projectionMatrix, viewMatrix) {
        // Set up alpha blending for transparent blocks
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);

        // Use the shader program
        this.gl.useProgram(this.programInfo.program);

        // Set light direction
        this.gl.uniform3fv(this.programInfo.uniformLocations.lightDirection, [0.5, 1.0, 0.3]);

        // Draw each mesh
        let drawnChunks = 0;

        for (const mesh of meshes) {
            // Skip empty meshes
            if (mesh.vertexCount === 0) continue;

            // Create model matrix with world offset
            const modelMatrix = mat4.create();
            mat4.translate(modelMatrix, modelMatrix, mesh.worldOffset);

            // Combine with view matrix
            const modelViewMatrix = mat4.create();
            mat4.multiply(modelViewMatrix, viewMatrix, modelMatrix);

            // Normal matrix
            const normalMatrix = mat4.create();
            mat4.invert(normalMatrix, modelViewMatrix);
            mat4.transpose(normalMatrix, normalMatrix);

            // Bind position buffer
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.position);
            this.gl.vertexAttribPointer(
                this.programInfo.attribLocations.vertexPosition,
                3, this.gl.FLOAT, false, 0, 0);
            this.gl.enableVertexAttribArray(this.programInfo.attribLocations.vertexPosition);

            // Bind normal buffer
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.normal);
            this.gl.vertexAttribPointer(
                this.programInfo.attribLocations.vertexNormal,
                3, this.gl.FLOAT, false, 0, 0);
            this.gl.enableVertexAttribArray(this.programInfo.attribLocations.vertexNormal);

            // Bind color buffer
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.color);
            this.gl.vertexAttribPointer(
                this.programInfo.attribLocations.vertexColor,
                4, this.gl.FLOAT, false, 0, 0);
            this.gl.enableVertexAttribArray(this.programInfo.attribLocations.vertexColor);

            // Bind index buffer
            this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, mesh.indices);

            // Set uniforms
            this.gl.uniformMatrix4fv(
                this.programInfo.uniformLocations.projectionMatrix,
                false, projectionMatrix);
            this.gl.uniformMatrix4fv(
                this.programInfo.uniformLocations.modelViewMatrix,
                false, modelViewMatrix);
            this.gl.uniformMatrix4fv(
                this.programInfo.uniformLocations.normalMatrix,
                false, normalMatrix);

            // Draw the chunk
            this.gl.drawElements(
                this.gl.TRIANGLES,
                mesh.vertexCount,
                this.gl.UNSIGNED_SHORT,
                0);

            drawnChunks++;
        }

        this.gl.disable(this.gl.BLEND);
        return drawnChunks;
    }
}</content></file><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/old_0/js/voxel-data.js</path><content>import { CHUNK_SIZE, DEBUG } from './constants.js';
import { debugLog } from './math-utils.js';

export class Chunk {
    constructor() {
        this.voxels = new Uint8Array(CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE);
        this.modified = true;
    }

    getVoxel(x, y, z) {
        if (x < 0 || x >= CHUNK_SIZE || y < 0 || y >= CHUNK_SIZE || z < 0 || z >= CHUNK_SIZE) {
            return 0; // Out of bounds
        }
        const index = (y * CHUNK_SIZE * CHUNK_SIZE) + (z * CHUNK_SIZE) + x;
        return this.voxels[index];
    }

    setVoxel(x, y, z, voxelType) {
        if (x < 0 || x >= CHUNK_SIZE || y < 0 || y >= CHUNK_SIZE || z < 0 || z >= CHUNK_SIZE) {
            return; // Out of bounds
        }
        const index = (y * CHUNK_SIZE * CHUNK_SIZE) + (z * CHUNK_SIZE) + x;
        this.voxels[index] = voxelType;
        this.modified = true;
    }

    isEmpty() {
        // Quick check if chunk is completely empty (all air)
        for (let i = 0; i < this.voxels.length; i++) {
            if (this.voxels[i] !== 0) {
                return false;
            }
        }
        return true;
    }
}</content></file><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/old_0/js/voxel-types.js</path><content>export const VoxelType = {
    AIR: 0,
    GRASS: 1,
    BEDROCK: 2,
    STONE: 3,
    DIRT: 4,
    WATER: 5
};

export class VoxelTypeManager {
    constructor() {
        this.types = new Map();
        this.setupDefaultTypes();
    }

    setupDefaultTypes() {
        // Air
        this.registerType(VoxelType.AIR, {
            name: "Air",
            transparent: true,
            solid: false,
            getColor: () => [0, 0, 0, 0]
        });

        // Grass
        this.registerType(VoxelType.GRASS, {
            name: "Grass",
            transparent: false,
            solid: true,
            getColor: (face) => {
                if (face === 'top') return [0.3, 0.75, 0.3, 1.0]; // Top - green
                if (face === 'bottom') return [0.5, 0.3, 0.1, 1.0]; // Bottom - dirt color
                return [0.4, 0.5, 0.2, 1.0]; // Sides - grass side
            }
        });

        // Bedrock
        this.registerType(VoxelType.BEDROCK, {
            name: "Bedrock",
            transparent: false,
            solid: true,
            getColor: () => [0.2, 0.2, 0.2, 1.0]
        });

        // Stone
        this.registerType(VoxelType.STONE, {
            name: "Stone",
            transparent: false,
            solid: true,
            getColor: () => [0.5, 0.5, 0.5, 1.0]
        });

        // Dirt
        this.registerType(VoxelType.DIRT, {
            name: "Dirt",
            transparent: false,
            solid: true,
            getColor: () => [0.5, 0.3, 0.1, 1.0]
        });

        // Water
        this.registerType(VoxelType.WATER, {
            name: "Water",
            transparent: true,
            solid: true, // Semi-solid for physics
            getColor: () => [0.0, 0.3, 0.8, 0.7]
        });
    }

    registerType(id, properties) {
        this.types.set(id, properties);
    }

    getType(id) {
        return this.types.get(id) || this.types.get(VoxelType.AIR);
    }

    isTransparent(id) {
        const type = this.getType(id);
        return type.transparent;
    }

    isSolid(id) {
        const type = this.getType(id);
        return type.solid;
    }

    getColor(id, face) {
        const type = this.getType(id);
        return type.getColor(face);
    }
}</content></file><file><path>/Users/estebanlanter/Documents/JOB2023/movalogic/old_0/js/world-generator.js</path><content>import { CHUNK_SIZE, MAX_HEIGHT } from './constants.js';
import { VoxelType } from './voxel-types.js';
import { Chunk } from './voxel-data.js';

export class WorldGenerator {
    constructor() {
        // Seed for reproducible generation
        this.seed = Math.random() * 10000;
    }

    // Generate terrain for a chunk
    generateChunk(chunkX, chunkY, chunkZ) {
        const chunk = new Chunk();

        // Calculate world position of chunk
        const worldX = chunkX * CHUNK_SIZE;
        const worldY = chunkY * CHUNK_SIZE;
        const worldZ = chunkZ * CHUNK_SIZE;

        // Generate terrain
        for (let x = 0; x < CHUNK_SIZE; x++) {
            for (let z = 0; z < CHUNK_SIZE; z++) {
                // World coordinates
                const wx = worldX + x;
                const wz = worldZ + z;

                // Generate a height value using noise
                const baseHeight = this.getHeight(wx, wz);

                // Fill voxels up to the height
                for (let y = 0; y < CHUNK_SIZE; y++) {
                    const wy = worldY + y;

                    // Determine voxel type based on height
                    let voxelType = VoxelType.AIR;

                    if (wy < baseHeight) {
                        // Below surface
                        if (wy < 1) {
                            voxelType = VoxelType.BEDROCK;
                        } else if (wy < baseHeight - 5) {
                            voxelType = VoxelType.STONE;
                        } else if (wy < baseHeight - 1) {
                            voxelType = VoxelType.DIRT;
                        } else {
                            voxelType = VoxelType.GRASS;
                        }

                        // Cave generation
                        if (voxelType !== VoxelType.BEDROCK && this.getCaveNoise(wx, wy, wz) > 0.7) {
                            voxelType = VoxelType.AIR;
                        }
                    } else if (wy < 8) {
                        // Water
                        voxelType = VoxelType.WATER;
                    }

                    // Set voxel in chunk
                    chunk.setVoxel(x, y, z, voxelType);
                }
            }
        }

        return chunk;
    }

    // Height map generation
    getHeight(x, z) {
        // Large scale terrain features
        const mountainHeight = this.smoothNoise(x * 0.01, z * 0.01) * 40;

        // Medium scale rolling hills
        const hillHeight = this.smoothNoise(x * 0.05, z * 0.05) * 10;

        // Small scale detail
        const detailHeight = this.smoothNoise(x * 0.2, z * 0.2) * 3;

        // Combine the different scales
        return Math.floor(10 + mountainHeight + hillHeight + detailHeight);
    }

    // Cave noise function
    getCaveNoise(x, y, z) {
        // 3D noise for cave generation
        return this.smoothNoise3D(x * 0.1, y * 0.1, z * 0.1);
    }

    // Noise functions
    smoothNoise(x, z) {
        // Get integer coordinates
        const x0 = Math.floor(x);
        const z0 = Math.floor(z);

        // Get fractional part
        const xf = x - x0;
        const zf = z - z0;

        // Get corners
        const n00 = this.noise2D(x0, z0);
        const n10 = this.noise2D(x0 + 1, z0);
        const n01 = this.noise2D(x0, z0 + 1);
        const n11 = this.noise2D(x0 + 1, z0 + 1);

        // Interpolate
        const nx0 = this.lerp(n00, n10, xf);
        const nx1 = this.lerp(n01, n11, xf);
        return this.lerp(nx0, nx1, zf);
    }

    smoothNoise3D(x, y, z) {
        // Simplified 3D noise
        const xy = this.smoothNoise(x, y) * 0.5 + 0.5;
        const yz = this.smoothNoise(y, z) * 0.5 + 0.5;
        const xz = this.smoothNoise(x, z) * 0.5 + 0.5;

        return (xy + yz + xz) / 3;
    }

    noise2D(x, z) {
        // Simple hash function with seed
        const n = Math.sin(x * 12.9898 + z * 78.233 + this.seed) * 43758.5453;
        return n - Math.floor(n);
    }

    lerp(a, b, t) {
        // Smooth interpolation
        const t2 = (1 - Math.cos(t * Math.PI)) / 2;
        return a * (1 - t2) + b * t2;
    }
}</content></file></codebase></codebase></codebase>