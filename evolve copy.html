<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GPU-Based Fractal Voxel World - Debug Mode (Fixed)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }

        canvas {
            display: block;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }

        #error {
            position: absolute;
            top: 10px;
            right: 10px;
            color: red;
            font-family: monospace;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            max-width: 400px;
            word-wrap: break-word;
            display: none;
        }

        #debug {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: yellow;
            font-family: monospace;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            max-width: 600px;
            max-height: 200px;
            overflow-y: auto;
            word-wrap: break-word;
        }

        #camera-info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: lime;
            font-family: monospace;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }

        #controls-info {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-family: monospace;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
    </style>
</head>

<body>
    <div id="info">GPU-Based Fractal Voxel World - DEBUG MODE<br>
        <span id="fps">FPS: 0</span><br>
        <span id="resolution">Resolution: 0</span>
    </div>
    <div id="error"></div>
    <div id="debug">Debug info will appear here...</div>
    <div id="camera-info">Camera: x=0, y=0, z=0</div>
    <div id="controls-info">
        WASD/Arrows: Move Camera | QE: Up/Down | R: Reset Camera | Mouse: Look | Space: Toggle Auto-Orbit
    </div>

    <!-- Load Three.js and dat.GUI -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>

    <script>
        /********************************************************
         * Debug / Error Handling
         ********************************************************/
        function debugLog(message) {
            const debugElement = document.getElementById('debug');
            debugElement.innerHTML += message + '<br>';
            // Keep only last 10 messages
            const lines = debugElement.innerHTML.split('<br>');
            if (lines.length > 10) {
                debugElement.innerHTML = lines.slice(lines.length - 10).join('<br>');
            }
            console.log(message);
        }

        window.onerror = function (message, source, lineno, colno, error) {
            const errorElement = document.getElementById('error');
            errorElement.textContent = `Error: ${message} at line ${lineno}:${colno}`;
            errorElement.style.display = 'block';
            console.error(error);
            debugLog(`ERROR: ${message}`);
            return true; // Prevent default error handling
        };

        function checkWebGL() {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (!gl) {
                document.getElementById('error').textContent = 'WebGL not supported by your browser';
                document.getElementById('error').style.display = 'block';
                debugLog('ERROR: WebGL not supported');
                return false;
            }
            debugLog(`WebGL Version: ${gl.getParameter(gl.VERSION)}`);
            debugLog(`WebGL Vendor: ${gl.getParameter(gl.VENDOR)}`);
            debugLog(`WebGL Renderer: ${gl.getParameter(gl.RENDERER)}`);
            return true;
        }

        /********************************************************
         * Main App
         ********************************************************/
        function init() {
            if (!checkWebGL()) return;

            debugLog('WebGL available, initializing...');

            const config = {
                resolution: 256,
                globalScale: 1.0,
                noiseScale: 0.1,
                speed: 0.2,
                amplitude: 1.5,
                colorMode: 0,
                densityThreshold: 0.5,
                cameraSpeed: 0.5,
                renderMode: 0,
                showReferenceGrid: true,
                autoOrbit: true
            };

            const controls = {
                moveForward: false,
                moveBackward: false,
                moveLeft: false,
                moveRight: false,
                moveUp: false,
                moveDown: false,
                lookSpeed: 0.002,
                moveSpeed: 0.1,
                mouseDown: false,
                mouseX: 0,
                mouseY: 0,
                pitch: 0,
                yaw: 0,
                resetRequested: false
            };

            // Scene + Camera
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.0, 3.0);
            camera.lookAt(0, 0, 0);

            // Renderer
            let renderer;
            try {
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                document.body.appendChild(renderer.domElement);
                debugLog('Renderer created successfully');
            } catch (e) {
                debugLog(`ERROR creating renderer: ${e.message}`);
                const errEl = document.getElementById('error');
                errEl.textContent = `WebGL Renderer Error: ${e.message}`;
                errEl.style.display = 'block';
                return;
            }

            // Reference Helpers
            const gridHelper = new THREE.GridHelper(10, 10, 0x888888, 0x444444);
            scene.add(gridHelper);

            const cubeGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const cubeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const cube = new THREE.Mesh(cubeGeo, cubeMat);
            cube.position.set(0, 0, 0);
            scene.add(cube);

            const axesHelper = new THREE.AxesHelper(1);
            scene.add(axesHelper);

            // Color Palettes
            const colorPalettes = [
                // Dreamscape (7 colors)
                [
                    new THREE.Vector3(0.0, 0.0, 0.4),
                    new THREE.Vector3(0.0, 0.33, 0.67),
                    new THREE.Vector3(0.0, 0.6, 0.8),
                    new THREE.Vector3(0.0, 0.8, 0.67),
                    new THREE.Vector3(0.33, 0.67, 1.0),
                    new THREE.Vector3(0.67, 0.87, 1.0),
                    new THREE.Vector3(1.0, 1.0, 1.0)
                ],
                // Sunset (6 colors)
                [
                    new THREE.Vector3(0.2, 0.0, 0.2),
                    new THREE.Vector3(0.4, 0.0, 0.4),
                    new THREE.Vector3(0.6, 0.2, 0.4),
                    new THREE.Vector3(1.0, 0.4, 0.2),
                    new THREE.Vector3(1.0, 0.67, 0.2),
                    new THREE.Vector3(1.0, 1.0, 0.6)
                ],
                // Alien (6 colors)
                [
                    new THREE.Vector3(0.0, 0.07, 0.13),
                    new THREE.Vector3(0.0, 0.2, 0.33),
                    new THREE.Vector3(0.0, 0.67, 0.53),
                    new THREE.Vector3(0.2, 1.0, 0.6),
                    new THREE.Vector3(0.67, 1.0, 0.4),
                    new THREE.Vector3(0.47, 0.87, 0.67)
                ]
            ];

            /********************************************************
             * Shaders
             ********************************************************/
            const vertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = vec4(position, 1.0);
                }
            `;

            // -----------------------------------------------------
            // IMPORTANT: We added a uniform `vec3 cameraPos;`
            //            Instead of referencing `cameraPosition`.
            // -----------------------------------------------------
            const fragmentShader = `
                uniform vec2 resolution;
                uniform float time;
                uniform float globalScale;
                uniform mat4 cameraWorldMatrix;
                uniform mat4 cameraProjectionMatrixInverse;
                uniform vec3 cameraPos;           // <-- NEW
                uniform float noiseScale;
                uniform float amplitude;
                uniform float densityThreshold;
                uniform int colorMode;
                uniform float speed;
                uniform int renderMode;

                // Palettes
                uniform vec3 palette0[7];
                uniform vec3 palette1[6];
                uniform vec3 palette2[6];

                const int MAX_STEPS = 100;
                const float MAX_DIST = 100.0;
                const float EPSILON = 0.01;

                float hash(vec3 p) {
                    p = fract(p * vec3(123.34, 234.34, 345.65));
                    p += dot(p, p + 34.45);
                    return fract(p.x * p.y * p.z);
                }

                float noise3D(vec3 p) {
                    vec3 i = floor(p);
                    vec3 f = fract(p);

                    vec3 u = f * f * (3.0 - 2.0 * f);

                    float a = hash(i + vec3(0.0, 0.0, 0.0));
                    float b = hash(i + vec3(1.0, 0.0, 0.0));
                    float c = hash(i + vec3(0.0, 1.0, 0.0));
                    float d = hash(i + vec3(1.0, 1.0, 0.0));
                    float e = hash(i + vec3(0.0, 0.0, 1.0));
                    float f1 = hash(i + vec3(1.0, 0.0, 1.0));
                    float g = hash(i + vec3(0.0, 1.0, 1.0));
                    float h = hash(i + vec3(1.0, 1.0, 1.0));

                    float k0 = a;
                    float k1 = b - a;
                    float k2 = c - a;
                    float k3 = e - a;
                    float k4 = a - b - c + d;
                    float k5 = a - c - e + g;
                    float k6 = a - b - e + f1;
                    float k7 = -a + b + c - d + e - f1 - g + h;

                    return k0 + 
                        k1 * u.x + 
                        k2 * u.y + 
                        k3 * u.z + 
                        k4 * u.x * u.y + 
                        k5 * u.y * u.z + 
                        k6 * u.z * u.x + 
                        k7 * u.x * u.y * u.z;
                }

                float fbm(vec3 p) {
                    float value = 0.0;
                    float amp = 1.0;
                    float freq = 1.0;

                    for (int i = 0; i < 3; i++) {
                        vec3 q = p;
                        q.x += time * speed * (0.3 * float(i) + 1.0) * 0.1;
                        q.z += time * speed * (0.2 * float(i) + 0.5) * 0.1;

                        value += amp * noise3D(freq * q);
                        amp *= 0.5;
                        freq *= 2.0;
                    }

                    // Map from -1..1 to 0..1
                    return value * 0.5 + 0.5;
                }

                vec3 getColor(float height) {
                    if (colorMode == 0) {
                        // Dreamscape (7 colors)
                        float idx = clamp(height, 0.0, 1.0) * 6.0;
                        int index = int(floor(idx));
                        float frac = fract(idx);
                        if (index >= 6) return palette0[6];
                        return mix(palette0[index], palette0[index+1], frac);
                    }
                    else if (colorMode == 1) {
                        // Sunset (6 colors)
                        float idx = clamp(height, 0.0, 1.0) * 5.0;
                        int index = int(floor(idx));
                        float frac = fract(idx);
                        if (index >= 5) return palette1[5];
                        return mix(palette1[index], palette1[index+1], frac);
                    }
                    else {
                        // Alien (6 colors)
                        float idx = clamp(height, 0.0, 1.0) * 5.0;
                        int index = int(floor(idx));
                        float frac = fract(idx);
                        if (index >= 5) return palette2[5];
                        return mix(palette2[index], palette2[index+1], frac);
                    }
                }

                float sdfTerrain(vec3 p) {
                    p = p / globalScale;
                    float ground = p.y + 0.5;
                    vec3 scaledPos = p * noiseScale;
                    float nVal = fbm(scaledPos);
                    float terrainDistance = p.y - (nVal * amplitude - 0.5 * amplitude);
                    return min(terrainDistance, ground) * globalScale;
                }

                vec3 calcNormal(vec3 p) {
                    vec2 e = vec2(EPSILON, 0.0);
                    float d1 = sdfTerrain(p + e.xyy);
                    float d2 = sdfTerrain(p - e.xyy);
                    float d3 = sdfTerrain(p + e.yxy);
                    float d4 = sdfTerrain(p - e.yxy);
                    float d5 = sdfTerrain(p + e.yyx);
                    float d6 = sdfTerrain(p - e.yyx);
                    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));
                }

                vec4 rayMarch(vec3 ro, vec3 rd) {
                    float t = 0.05;

                    for (int i = 0; i < MAX_STEPS; i++) {
                        vec3 p = ro + rd * t;
                        float d = sdfTerrain(p);

                        // Debug SDF
                        if (renderMode == 1) {
                            if (d < EPSILON) {
                                return vec4(1.0, 0.0, 0.0, 1.0);
                            }
                            float depthCue = clamp(1.0 - t / 20.0, 0.0, 1.0);
                            float sdfValue = clamp(abs(d) / 5.0, 0.0, 1.0);
                            vec3 color = (d < 0.0)
                                ? mix(vec3(1.0, 0.0, 0.0), vec3(0.5, 0.0, 0.0), sdfValue)
                                : mix(vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, 0.5), sdfValue);
                            color *= depthCue;

                            t += max(0.1, abs(d) * 0.5);
                            if (i == MAX_STEPS - 1 || t > MAX_DIST) {
                                return vec4(color, 1.0);
                            }
                            continue;
                        }
                        // Debug Normals
                        else if (renderMode == 2) {
                            if (d < EPSILON) {
                                vec3 n = calcNormal(p);
                                return vec4(n * 0.5 + 0.5, 1.0);
                            }
                        }
                        // Normal rendering
                        else {
                            if (d < EPSILON) {
                                vec3 n = calcNormal(p);
                                float height = (p.y / globalScale + amplitude) / (2.0 * amplitude);
                                vec3 lightDir = normalize(vec3(0.5, 1.0, 0.3));
                                float diffuse = max(0.2, dot(n, lightDir));
                                vec3 col = getColor(height) * diffuse;
                                float fogFactor = 1.0 - clamp(t / MAX_DIST, 0.0, 1.0);
                                col = mix(vec3(0.5, 0.6, 0.7), col, fogFactor);
                                return vec4(col, 1.0);
                            }
                        }

                        t += max(0.02, abs(d) * 0.5);
                        if (t > MAX_DIST) break;
                    }

                    // Sky fallback
                    float t2 = 0.5 + 0.5 * rd.y;
                    vec3 sky = mix(vec3(0.5, 0.7, 1.0), vec3(0.2, 0.3, 0.5), t2);
                    return vec4(sky, 1.0);
                }

                void main() {
                    vec2 uv = gl_FragCoord.xy / resolution.xy;
                    uv = uv * 2.0 - 1.0;
                    uv.x *= resolution.x / resolution.y;

                    // Unproject from NDC -> Camera space
                    vec4 csPos = cameraProjectionMatrixInverse * vec4(uv, -1.0, 1.0);
                    // Transform from Camera space -> World space
                    vec4 wsPos = cameraWorldMatrix * csPos;

                    // Ray direction = world-space position minus cameraPos
                    vec3 rd = normalize(wsPos.xyz - cameraPos);  // <-- CHANGED
                    vec3 ro = cameraPos;                         // <-- CHANGED

                    // Ray march
                    vec4 color = rayMarch(ro, rd);
                    gl_FragColor = color;
                }
            `;

            /********************************************************
             * Create Shader Material + Uniforms
             ********************************************************/
            const uniforms = {
                resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                time: { value: 0.0 },
                globalScale: { value: config.globalScale },
                cameraWorldMatrix: { value: new THREE.Matrix4() },
                cameraProjectionMatrixInverse: { value: new THREE.Matrix4() },
                cameraPos: { value: new THREE.Vector3() }, // <-- NEW
                noiseScale: { value: config.noiseScale },
                amplitude: { value: config.amplitude },
                densityThreshold: { value: config.densityThreshold },
                colorMode: { value: config.colorMode },
                speed: { value: config.speed },
                renderMode: { value: config.renderMode },
            };

            // Attach color palettes
            for (let p = 0; p < colorPalettes.length; p++) {
                for (let c = 0; c < colorPalettes[p].length; c++) {
                    uniforms[`palette${p}[${c}]`] = { value: colorPalettes[p][c] };
                }
            }

            // Full-screen quad
            const quadGeom = new THREE.PlaneGeometry(2, 2);

            let material;
            try {
                material = new THREE.ShaderMaterial({
                    uniforms: uniforms,
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader
                });
                debugLog('Shader material created successfully');
            } catch (e) {
                debugLog(`ERROR creating shader material: ${e.message}`);
                const errEl = document.getElementById('error');
                errEl.textContent = `Shader Error: ${e.message}`;
                errEl.style.display = 'block';
                return;
            }

            const quad = new THREE.Mesh(quadGeom, material);
            scene.add(quad);
            debugLog('Added quad to scene');

            /********************************************************
             * dat.GUI
             ********************************************************/
            const gui = new dat.GUI();
            gui.add(config, 'globalScale', 0.1, 10.0).name('Global Scale').onChange(v => uniforms.globalScale.value = v);
            gui.add(config, 'noiseScale', 0.01, 0.5).name('Noise Scale').onChange(v => uniforms.noiseScale.value = v);
            gui.add(config, 'speed', 0.05, 1.0).name('Evolution Speed').onChange(v => uniforms.speed.value = v);
            gui.add(config, 'amplitude', 0.5, 3.0).name('Terrain Height').onChange(v => uniforms.amplitude.value = v);
            gui.add(config, 'colorMode', { Dreamscape: 0, Sunset: 1, Alien: 2 }).name('Color Theme').onChange(v => uniforms.colorMode.value = parseInt(v));
            gui.add(config, 'renderMode', { Normal: 0, 'Debug SDF': 1, 'Debug Normals': 2 }).name('Render Mode').onChange(v => uniforms.renderMode.value = parseInt(v));
            gui.add(config, 'showReferenceGrid').name('Show Grid').onChange(v => {
                gridHelper.visible = v;
                cube.visible = v;
                axesHelper.visible = v;
            });
            gui.add(config, 'autoOrbit').name('Auto Orbit');
            gui.add(config, 'cameraSpeed', 0.1, 2.0).name('Orbit Speed');
            gui.add(controls, 'moveSpeed', 0.01, 1.0).name('Move Speed');

            document.getElementById('resolution').textContent = `Resolution: ${window.innerWidth}x${window.innerHeight}`;

            // Simple orbit logic
            let angle = 0;

            controls.yaw = Math.PI; // face origin
            controls.pitch = 0;

            function resetCamera() {
                camera.position.set(0, 1.0, 3.0);
                controls.yaw = Math.PI;
                controls.pitch = 0;
                updateCameraRotation();
            }

            function updateCameraRotation() {
                controls.pitch = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, controls.pitch));
                const dir = new THREE.Vector3(
                    Math.sin(controls.yaw) * Math.cos(controls.pitch),
                    Math.sin(controls.pitch),
                    Math.cos(controls.yaw) * Math.cos(controls.pitch)
                );
                camera.lookAt(camera.position.clone().add(dir));
            }

            /********************************************************
             * Input Handlers
             ********************************************************/
            document.addEventListener('keydown', (e) => {
                switch (e.key.toLowerCase()) {
                    case 'w': case 'arrowup': controls.moveForward = true; break;
                    case 's': case 'arrowdown': controls.moveBackward = true; break;
                    case 'a': case 'arrowleft': controls.moveLeft = true; break;
                    case 'd': case 'arrowright': controls.moveRight = true; break;
                    case 'q': controls.moveDown = true; break;
                    case 'e': controls.moveUp = true; break;
                    case 'r': controls.resetRequested = true; break;
                    case ' ': config.autoOrbit = !config.autoOrbit; break;
                }
            });
            document.addEventListener('keyup', (e) => {
                switch (e.key.toLowerCase()) {
                    case 'w': case 'arrowup': controls.moveForward = false; break;
                    case 's': case 'arrowdown': controls.moveBackward = false; break;
                    case 'a': case 'arrowleft': controls.moveLeft = false; break;
                    case 'd': case 'arrowright': controls.moveRight = false; break;
                    case 'q': controls.moveDown = false; break;
                    case 'e': controls.moveUp = false; break;
                }
            });
            document.addEventListener('mousedown', (e) => {
                controls.mouseDown = true;
                controls.mouseX = e.clientX;
                controls.mouseY = e.clientY;
            });
            document.addEventListener('mouseup', () => controls.mouseDown = false);
            document.addEventListener('mousemove', (e) => {
                if (controls.mouseDown) {
                    const dx = e.clientX - controls.mouseX;
                    const dy = e.clientY - controls.mouseY;

                    controls.yaw -= dx * controls.lookSpeed;
                    controls.pitch -= dy * controls.lookSpeed;
                    updateCameraRotation();

                    controls.mouseX = e.clientX;
                    controls.mouseY = e.clientY;
                }
            });

            // Resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
                document.getElementById('resolution').textContent = `Resolution: ${window.innerWidth}x${window.innerHeight}`;
            });

            /********************************************************
             * Animation Loop
             ********************************************************/
            let frameCount = 0;
            let lastFpsUpdate = 0;

            function animate(timestamp) {
                requestAnimationFrame(animate);

                // FPS counter
                frameCount++;
                if (timestamp - lastFpsUpdate > 1000) {
                    const fps = Math.round(frameCount * 1000 / (timestamp - lastFpsUpdate));
                    document.getElementById('fps').textContent = `FPS: ${fps}`;
                    frameCount = 0;
                    lastFpsUpdate = timestamp;
                }

                const timeSec = timestamp * 0.001;
                uniforms.time.value = timeSec;

                // Auto-orbit
                if (config.autoOrbit) {
                    angle += 0.002 * config.cameraSpeed;
                    if (!controls.mouseDown) {
                        controls.yaw = angle + Math.PI;
                        updateCameraRotation();
                    }
                }

                // Reset camera if requested
                if (controls.resetRequested) {
                    resetCamera();
                    controls.resetRequested = false;
                }

                // WASD movement
                const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                const up = new THREE.Vector3(0, 1, 0);

                if (controls.moveForward) camera.position.addScaledVector(dir, controls.moveSpeed);
                if (controls.moveBackward) camera.position.addScaledVector(dir, -controls.moveSpeed);
                if (controls.moveLeft) camera.position.addScaledVector(right, -controls.moveSpeed);
                if (controls.moveRight) camera.position.addScaledVector(right, controls.moveSpeed);
                if (controls.moveUp) camera.position.addScaledVector(up, controls.moveSpeed);
                if (controls.moveDown) camera.position.addScaledVector(up, -controls.moveSpeed);

                document.getElementById('camera-info').textContent =
                    `Camera: x=${camera.position.x.toFixed(2)}, y=${camera.position.y.toFixed(2)}, z=${camera.position.z.toFixed(2)}`;

                // Update camera for the shader
                camera.updateMatrixWorld();
                camera.updateProjectionMatrix();
                uniforms.cameraWorldMatrix.value.copy(camera.matrixWorld);
                uniforms.cameraProjectionMatrixInverse.value.copy(camera.projectionMatrix).invert();

                // <-- NEW: Pass real camera position to the shader
                uniforms.cameraPos.value.copy(camera.position);

                renderer.render(scene, camera);
            }

            debugLog('Starting animation loop');
            animate(0);
        }

        window.onload = init;
    </script>
</body>

</html>